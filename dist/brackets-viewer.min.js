/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/dom.ts":
/*!********************!*\
  !*** ./src/dom.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.setupConnection = exports.getFinalConnection = exports.getBracketConnection = exports.addParticipantImage = exports.addParticipantOrigin = exports.setupLoss = exports.setupWin = exports.setupBye = exports.setupHint = exports.createRankingHeaders = exports.createCell = exports.createRow = exports.createTable = exports.createResultContainer = exports.createNameContainer = exports.createParticipantContainer = exports.createOpponentsContainer = exports.createChildCountLabel = exports.createMatchLabel = exports.createMatchContainer = exports.createRoundContainer = exports.createRoundsContainer = exports.createGroupContainer = exports.createBracketContainer = exports.createEliminationContainer = exports.createRoundRobinContainer = exports.createTitle = void 0;\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n\nconst lang_1 = __webpack_require__(/*! ./lang */ \"./src/lang.ts\");\n/**\n * Creates the title of the viewer.\n *\n * @param title The title to set.\n */\n\n\nfunction createTitle(title) {\n  const h1 = document.createElement('h1');\n  h1.innerText = title;\n  return h1;\n}\n\nexports.createTitle = createTitle;\n/**\n * Creates a container which contains a round-robin stage.\n *\n * @param stageId ID of the stage.\n */\n\nfunction createRoundRobinContainer(stageId) {\n  const stage = document.createElement('div');\n  stage.classList.add('round-robin');\n  stage.setAttribute('data-stage-id', stageId.toString());\n  return stage;\n}\n\nexports.createRoundRobinContainer = createRoundRobinContainer;\n/**\n * Creates a container which contains an elimination stage.\n *\n * @param stageId ID of the stage.\n */\n\nfunction createEliminationContainer(stageId) {\n  const stage = document.createElement('div');\n  stage.classList.add('elimination');\n  stage.setAttribute('data-stage-id', stageId.toString());\n  return stage;\n}\n\nexports.createEliminationContainer = createEliminationContainer;\n/**\n * Creates a container which contains one bracket of a single or double elimination stage.\n *\n * @param groupId ID of the group.\n * @param title Title of the group.\n */\n\nfunction createBracketContainer(groupId, title) {\n  const bracket = document.createElement('section');\n  bracket.classList.add('bracket');\n  bracket.setAttribute('data-group-id', groupId.toString());\n\n  if (title) {\n    const h2 = document.createElement('h2');\n    h2.innerText = title;\n    bracket.append(h2);\n  }\n\n  return bracket;\n}\n\nexports.createBracketContainer = createBracketContainer;\n/**\n * Creates a container which contains a group for round-robin stages.\n *\n * @param groupId ID of the group.\n * @param title Title of the group.\n */\n\nfunction createGroupContainer(groupId, title) {\n  const h2 = document.createElement('h2');\n  h2.innerText = title;\n  const group = document.createElement('section');\n  group.classList.add('group');\n  group.setAttribute('data-group-id', groupId.toString());\n  group.append(h2);\n  return group;\n}\n\nexports.createGroupContainer = createGroupContainer;\n/**\n * Creates a container which contains a list of rounds.\n */\n\nfunction createRoundsContainer() {\n  const round = document.createElement('div');\n  round.classList.add('rounds');\n  return round;\n}\n\nexports.createRoundsContainer = createRoundsContainer;\n/**\n * Creates a container which contains a round.\n *\n * @param roundId ID of the round.\n * @param title Title of the round.\n */\n\nfunction createRoundContainer(roundId, title, onClick) {\n  const h3 = document.createElement('h3');\n  h3.innerText = title;\n  onClick && h3.addEventListener('click', onClick);\n  const round = document.createElement('article');\n  round.classList.add('round');\n  round.setAttribute('data-round-id', roundId.toString());\n  round.append(h3);\n  return round;\n}\n\nexports.createRoundContainer = createRoundContainer;\n/**\n * Creates a container which contains a match.\n *\n * @param matchId ID of the match.\n * @param status Status of the match.\n */\n\nfunction createMatchContainer(matchId, status) {\n  const match = document.createElement('div');\n  match.classList.add('match');\n  matchId !== undefined && match.setAttribute('data-match-id', matchId.toString());\n  status !== undefined && match.setAttribute('data-match-status', status.toString());\n  return match;\n}\n\nexports.createMatchContainer = createMatchContainer;\n/**\n * Creates a container which contains the label of a match.\n *\n * @param label The label of the match.\n * @param status The status to set as tooltip.\n */\n\nfunction createMatchLabel(label, status) {\n  const span = document.createElement('span');\n  span.innerText = label;\n  span.title = status;\n  return span;\n}\n\nexports.createMatchLabel = createMatchLabel;\n/**\n * Creates a container which contains the child count label of a match.\n *\n * @param label The child count label of the match.\n */\n\nfunction createChildCountLabel(label) {\n  const span = document.createElement('span');\n  span.innerText = label;\n  return span;\n}\n\nexports.createChildCountLabel = createChildCountLabel;\n/**\n * Creates a container which contains the opponents of a match.\n *\n * @param onClick Called when the match is clicked.\n */\n\nfunction createOpponentsContainer(onClick) {\n  const opponents = document.createElement('div');\n  opponents.classList.add('opponents');\n  onClick && opponents.addEventListener('click', onClick);\n  return opponents;\n}\n\nexports.createOpponentsContainer = createOpponentsContainer;\n/**\n * Creates a container which contains a participant.\n *\n * @param participantId ID of the participant.\n */\n\nfunction createParticipantContainer(participantId) {\n  const participant = document.createElement('div');\n  participant.classList.add('participant');\n  if (participantId !== null && participantId !== undefined) participant.setAttribute('data-participant-id', participantId.toString());\n  return participant;\n}\n\nexports.createParticipantContainer = createParticipantContainer;\n/**\n * Creates a container which contains the name of a participant.\n */\n\nfunction createNameContainer() {\n  const name = document.createElement('div');\n  name.classList.add('name');\n  return name;\n}\n\nexports.createNameContainer = createNameContainer;\n/**\n * Creates a container which contains the result of a match for a participant.\n */\n\nfunction createResultContainer() {\n  const result = document.createElement('div');\n  result.classList.add('result');\n  return result;\n}\n\nexports.createResultContainer = createResultContainer;\n/**\n * Creates a table.\n */\n\nfunction createTable() {\n  return document.createElement('table');\n}\n\nexports.createTable = createTable;\n/**\n * Creates a table row.\n */\n\nfunction createRow() {\n  return document.createElement('tr');\n}\n\nexports.createRow = createRow;\n/**\n * Creates a table cell.\n *\n * @param data The data in the cell.\n */\n\nfunction createCell(data) {\n  const td = document.createElement('td');\n  td.innerText = String(data);\n  return td;\n}\n\nexports.createCell = createCell;\n/**\n * Creates the headers for a ranking table.\n *\n * @param ranking The object containing the ranking.\n */\n\nfunction createRankingHeaders(ranking) {\n  const headers = document.createElement('tr');\n  const firstItem = ranking[0];\n\n  for (const key in firstItem) {\n    const prop = key;\n    const header = (0, helpers_1.rankingHeader)(prop);\n    const th = document.createElement('th');\n    th.innerText = header.text;\n    th.setAttribute('title', header.tooltip);\n    headers.append(th);\n  }\n\n  return headers;\n}\n\nexports.createRankingHeaders = createRankingHeaders;\n/**\n * Sets a hint on a name container.\n *\n * @param nameContainer The name container.\n * @param hint The hint to set.\n */\n\nfunction setupHint(nameContainer, hint) {\n  nameContainer.classList.add('hint');\n  nameContainer.innerText = hint;\n}\n\nexports.setupHint = setupHint;\n/**\n * Sets a BYE on a name container.\n *\n * @param nameContainer The name container.\n */\n\nfunction setupBye(nameContainer) {\n  nameContainer.innerText = (0, lang_1.t)('common.bye');\n  nameContainer.classList.add('bye');\n}\n\nexports.setupBye = setupBye;\n/**\n * Sets a win for a participant.\n *\n * @param participantContainer The participant container.\n * @param resultContainer The result container.\n * @param participant The participant result.\n */\n\nfunction setupWin(participantContainer, resultContainer, participant) {\n  if (participant.result && participant.result === 'win') {\n    participantContainer.classList.add('win');\n    if (participant.score === undefined) resultContainer.innerText = (0, lang_1.t)('abbreviations.win');\n  }\n}\n\nexports.setupWin = setupWin;\n/**\n * Sets a loss for a participant.\n *\n * @param participantContainer The participant container.\n * @param resultContainer The result container.\n * @param participant The participant result.\n */\n\nfunction setupLoss(participantContainer, resultContainer, participant) {\n  if (participant.result && participant.result === 'loss' || participant.forfeit) {\n    participantContainer.classList.add('loss');\n    if (participant.forfeit) resultContainer.innerText = (0, lang_1.t)('abbreviations.forfeit');else if (participant.score === undefined) resultContainer.innerText = (0, lang_1.t)('abbreviations.loss');\n  }\n}\n\nexports.setupLoss = setupLoss;\n/**\n * Adds the participant origin to a name.\n *\n * @param nameContainer The name container.\n * @param text The text to set (origin).\n * @param placement The placement of the participant origin.\n */\n\nfunction addParticipantOrigin(nameContainer, text, placement) {\n  const span = document.createElement('span');\n\n  if (placement === 'before') {\n    span.innerText = `${text} `;\n    nameContainer.prepend(span);\n  } else if (placement === 'after') {\n    span.innerText = ` (${text})`;\n    nameContainer.append(span);\n  }\n}\n\nexports.addParticipantOrigin = addParticipantOrigin;\n/**\n * Adds the participant image to a name.\n *\n * @param nameContainer The name container.\n * @param src Source of the image.\n */\n\nfunction addParticipantImage(nameContainer, src) {\n  const img = document.createElement('img');\n  img.src = src;\n  nameContainer.prepend(img);\n}\n\nexports.addParticipantImage = addParticipantImage;\n/**\n * Returns the connection for a given round in a bracket.\n *\n * @param alwaysConnectFirstRound Whether to always connect the first round with the second round.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param match The match to connect to other matches.\n * @param matchLocation Location of the match.\n * @param connectFinal Whether to connect to the final.\n */\n\nfunction getBracketConnection(alwaysConnectFirstRound, roundNumber, roundCount, match, matchLocation, connectFinal) {\n  var _a, _b, _c;\n\n  const connection = {\n    connectPrevious: false,\n    connectNext: false\n  };\n\n  if (matchLocation === 'loser-bracket') {\n    connection.connectPrevious = roundNumber > 1 && (roundNumber % 2 === 1 ? 'square' : 'straight');\n    connection.connectNext = roundNumber < roundCount && (roundNumber % 2 === 0 ? 'square' : 'straight');\n  } else {\n    connection.connectPrevious = roundNumber > 1 && 'square';\n    connection.connectNext = roundNumber < roundCount ? 'square' : connectFinal ? 'straight' : false;\n  }\n\n  if (alwaysConnectFirstRound || roundNumber !== 2) return connection;\n  const upperBracket = matchLocation === 'single-bracket' || matchLocation === 'winner-bracket';\n  if (upperBracket && ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) === undefined && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) === undefined) connection.connectPrevious = false;\n  if (matchLocation === 'loser-bracket' && ((_c = match.opponent2) === null || _c === void 0 ? void 0 : _c.position) === undefined) connection.connectPrevious = false;\n  return connection;\n}\n\nexports.getBracketConnection = getBracketConnection;\n/**\n * Returns the connection for a given round in the final.\n *\n * @param finalType Type of final.\n * @param roundNumber Number of the round.\n * @param matchCount The count of matches.\n */\n\nfunction getFinalConnection(finalType, roundNumber, matchCount) {\n  return {\n    connectPrevious: finalType === 'grand_final' && roundNumber === 1 && 'straight',\n    connectNext: matchCount === 2 && roundNumber === 1 && 'straight'\n  };\n}\n\nexports.getFinalConnection = getFinalConnection;\n/**\n * Sets the connection a match containers.\n *\n * @param opponentsContainer The opponents container.\n * @param matchContainer The match container.\n * @param connection The connection to set.\n */\n\nfunction setupConnection(opponentsContainer, matchContainer, connection) {\n  if (connection.connectPrevious) opponentsContainer.classList.add('connect-previous');\n  if (connection.connectNext) matchContainer.classList.add('connect-next');\n  if (connection.connectPrevious === 'straight') opponentsContainer.classList.add('straight');\n  if (connection.connectNext === 'straight') matchContainer.classList.add('straight');\n}\n\nexports.setupConnection = setupConnection;\n\n//# sourceURL=webpack://brackets-viewer/./src/dom.ts?");

/***/ }),

/***/ "./src/helpers.ts":
/*!************************!*\
  !*** ./src/helpers.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getRanking = exports.rankingHeader = exports.isMajorRound = exports.getOriginAbbreviation = exports.completeWithBlankMatches = exports.findRoot = exports.splitBy = void 0;\n\nconst lang_1 = __webpack_require__(/*! ./lang */ \"./src/lang.ts\");\n/**\n * Splits an array based on values of a given key of the objects of the array.\n *\n * @param array The array to split.\n * @param key The key of T.\n */\n\n\nfunction splitBy(array, key) {\n  const obj = Object();\n\n  for (const value of array) {\n    if (!obj[value[key]]) obj[value[key]] = [];\n    obj[value[key]].push(value);\n  }\n\n  return Object.values(obj);\n}\n\nexports.splitBy = splitBy;\n/**\n * Finds the root element\n *\n * @param selector An optional selector to select the root element.\n */\n\nfunction findRoot(selector) {\n  const queryResult = document.querySelectorAll(selector || '.brackets-viewer');\n  if (queryResult.length === 0) throw Error('Root not found. You must have at least one root element.');\n  if (queryResult.length > 1) throw Error('Multiple possible roots were found. Please use `config.selector` to choose a specific root.');\n  const root = queryResult[0];\n  if (!root.classList.contains('brackets-viewer')) throw Error('The selected root must have a `.brackets-viewer` class.');\n  return root;\n}\n\nexports.findRoot = findRoot;\n/**\n * Completes a list of matches with blank matches based on the next matches.\n *\n * Toornament can generate first rounds with an odd number of matches and the seeding is partially distributed in the second round.\n * This function adds a blank match in the first round as if it was the source match of a seeded match of the second round.\n *\n * @param bracketType Type of the bracket.\n * @param matches The list of first round matches.\n * @param nextMatches The list of second round matches.\n */\n\nfunction completeWithBlankMatches(bracketType, matches, nextMatches) {\n  if (!nextMatches) return {\n    matches,\n    fromToornament: false\n  };\n  let sources = [];\n  if (bracketType === 'single-bracket' || bracketType === 'winner-bracket') sources = nextMatches.map(match => {\n    var _a, _b;\n\n    return [((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) || null, ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) || null];\n  }).flat();\n  if (bracketType === 'loser-bracket') sources = nextMatches.map(match => {\n    var _a;\n\n    return ((_a = match.opponent2) === null || _a === void 0 ? void 0 : _a.position) || null;\n  }); // The manager does not set positions where the Toornament layer does.\n\n  if (sources.filter(source => source !== null).length === 0) return {\n    matches,\n    fromToornament: false\n  };\n  return {\n    matches: sources.map(source => source && matches.find(match => match.number === source) || null),\n    fromToornament: true\n  };\n}\n\nexports.completeWithBlankMatches = completeWithBlankMatches;\n/**\n * Returns the abbreviation for a participant origin.\n *\n * @param matchLocation Location of the match.\n * @param skipFirstRound Whether to skip the first round.\n * @param roundNumber Number of the round.\n * @param side Side of the participant.\n */\n\nfunction getOriginAbbreviation(matchLocation, skipFirstRound, roundNumber, side) {\n  roundNumber = roundNumber || -1;\n  if (skipFirstRound && matchLocation === 'loser-bracket' && roundNumber === 1) return (0, lang_1.t)('abbreviations.seed');\n  if (matchLocation === 'single-bracket' || matchLocation === 'winner-bracket' && roundNumber === 1) return (0, lang_1.t)('abbreviations.seed');\n  if (matchLocation === 'loser-bracket' && roundNumber % 2 === 0 && side === 'opponent1') return (0, lang_1.t)('abbreviations.position');\n  return null;\n}\n\nexports.getOriginAbbreviation = getOriginAbbreviation;\n/**\n * Indicates whether a round is major.\n *\n * @param roundNumber Number of the round.\n */\n\nfunction isMajorRound(roundNumber) {\n  return roundNumber === 1 || roundNumber % 2 === 0;\n}\n\nexports.isMajorRound = isMajorRound;\n/**\n * Returns the header for a ranking property.\n *\n * @param itemName Name of the ranking property.\n */\n\nfunction rankingHeader(itemName) {\n  return (0, lang_1.t)(`ranking.${itemName}`, {\n    returnObjects: true\n  });\n}\n\nexports.rankingHeader = rankingHeader;\n/**\n * Calculates the ranking based on a list of matches and a formula.\n *\n * @param matches The list of matches.\n * @param formula The points formula to apply.\n */\n\nfunction getRanking(matches, formula) {\n  formula = formula || (item => 3 * item.wins + 1 * item.draws + 0 * item.losses);\n\n  const rankingMap = {};\n\n  for (const match of matches) {\n    processParticipant(rankingMap, formula, match.opponent1, match.opponent2);\n    processParticipant(rankingMap, formula, match.opponent2, match.opponent1);\n  }\n\n  return createRanking(rankingMap);\n}\n\nexports.getRanking = getRanking;\n/**\n * Processes a participant and edits the ranking map.\n *\n * @param rankingMap The ranking map to edit.\n * @param formula The points formula to apply.\n * @param current The current participant.\n * @param other The opponent.\n */\n\nfunction processParticipant(rankingMap, formula, current, other) {\n  if (!current || current.id === null) return;\n  const state = rankingMap[current.id] || {\n    rank: 0,\n    id: 0,\n    played: 0,\n    wins: 0,\n    draws: 0,\n    losses: 0,\n    forfeits: 0,\n    scoreFor: 0,\n    scoreAgainst: 0,\n    scoreDifference: 0,\n    points: 0\n  };\n  state.id = current.id;\n  if (current.forfeit || current.result) state.played++;\n  if (current.result === 'win') state.wins++;\n  if (current.result === 'draw') state.draws++;\n  if (current.result === 'loss') state.losses++;\n  if (current.forfeit) state.forfeits++;\n  state.scoreFor += current.score || 0;\n  state.scoreAgainst += other && other.score || 0;\n  state.scoreDifference = state.scoreFor - state.scoreAgainst;\n  state.points = formula(state);\n  rankingMap[current.id] = state;\n}\n/**\n * Creates the final ranking based on a ranking map. (Sort + Total points)\n *\n * @param rankingMap The ranking map (object).\n */\n\n\nfunction createRanking(rankingMap) {\n  const ranking = Object.values(rankingMap).sort((a, b) => a.points !== b.points ? b.points - a.points : b.played - a.played);\n  const rank = {\n    value: 0,\n    lastPoints: -1\n  };\n\n  for (const item of ranking) {\n    item.rank = rank.lastPoints !== item.points ? ++rank.value : rank.value;\n    rank.lastPoints = item.points;\n  }\n\n  return ranking;\n}\n\n//# sourceURL=webpack://brackets-viewer/./src/helpers.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nconst brackets_memory_db_1 = __webpack_require__(/*! brackets-memory-db */ \"./node_modules/brackets-memory-db/dist/index.js\");\n\nconst brackets_manager_1 = __webpack_require__(/*! brackets-manager */ \"./node_modules/brackets-manager/dist/index.js\");\n\nconst main_1 = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n\nwindow.bracketsViewer = new main_1.BracketsViewer();\nwindow.inMemoryDatabase = new brackets_memory_db_1.InMemoryDatabase();\nwindow.bracketsManager = new brackets_manager_1.BracketsManager(window.inMemoryDatabase);\n\n//# sourceURL=webpack://brackets-viewer/./src/index.ts?");

/***/ }),

/***/ "./src/lang.ts":
/*!*********************!*\
  !*** ./src/lang.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getLoserBracketRoundName = exports.getWinnerBracketRoundName = exports.getRoundName = exports.getBracketName = exports.getGroupName = exports.getMatchStatus = exports.getFinalMatchLabel = exports.getMatchLabel = exports.getFinalOriginHint = exports.getOriginHint = exports.t = exports.addLocale = exports.locales = void 0;\n\nconst i18next_1 = __importDefault(__webpack_require__(/*! i18next */ \"./node_modules/i18next/dist/cjs/i18next.js\"));\n\nconst i18next_browser_languagedetector_1 = __importDefault(__webpack_require__(/*! i18next-browser-languagedetector */ \"./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js\"));\n\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n\nconst translation_json_1 = __importDefault(__webpack_require__(/*! ./i18n/en/translation.json */ \"./src/i18n/en/translation.json\"));\n\nconst translation_json_2 = __importDefault(__webpack_require__(/*! ./i18n/fr/translation.json */ \"./src/i18n/fr/translation.json\"));\n\nexports.locales = {\n  en: translation_json_1.default,\n  fr: translation_json_2.default\n};\ni18next_1.default.use(i18next_browser_languagedetector_1.default).init({\n  fallbackLng: 'en',\n  debug: false,\n  resources: {\n    en: {\n      translation: exports.locales.en\n    },\n    fr: {\n      translation: exports.locales.fr\n    }\n  }\n});\n/**\n * Adds a locale to the available i18n bundles.\n *\n * @param name Name of the locale.\n * @param locale Contents of the locale.\n */\n\nfunction addLocale(name, locale) {\n  i18next_1.default.addResourceBundle(name, 'translation', locale, true, true);\n  i18next_1.default.changeLanguage();\n}\n\nexports.addLocale = addLocale;\n/**\n * Returns an internationalized version of a locale key.\n *\n * @param key A locale key.\n * @param options Data to pass to the i18n process.\n */\n\nfunction t(key, options) {\n  return i18next_1.default.t(key, options);\n}\n\nexports.t = t;\n/**\n * Returns an origin hint function based on rounds information.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param skipFirstRound Whether to skip the first round.\n * @param matchLocation Location of the match.\n */\n\nfunction getOriginHint(roundNumber, roundCount, skipFirstRound, matchLocation) {\n  if (roundNumber === 1) {\n    if (matchLocation === 'single-bracket') return position => t('origin-hint.seed', {\n      position\n    });\n    if (matchLocation === 'winner-bracket') return position => t('origin-hint.seed', {\n      position\n    });\n    if (matchLocation === 'loser-bracket' && skipFirstRound) return position => t('origin-hint.seed', {\n      position\n    });\n  }\n\n  if ((0, helpers_1.isMajorRound)(roundNumber) && matchLocation === 'loser-bracket') {\n    if (roundNumber === roundCount - 2) return position => t('origin-hint.winner-bracket-semi-final', {\n      position\n    });\n    if (roundNumber === roundCount) return () => t('origin-hint.winner-bracket-final');\n    const roundNumberWB = Math.ceil((roundNumber + 1) / 2);\n    if (skipFirstRound) return position => t('origin-hint.winner-bracket', {\n      round: roundNumberWB - 1,\n      position\n    });\n    return position => t('origin-hint.winner-bracket', {\n      round: roundNumberWB,\n      position\n    });\n  }\n\n  return undefined;\n}\n\nexports.getOriginHint = getOriginHint;\n/**\n * Returns an origin hint function for a match in final.\n *\n * @param finalType Type of the final.\n * @param roundNumber Number of the round.\n */\n\nfunction getFinalOriginHint(finalType, roundNumber) {\n  // Single elimination.\n  if (finalType === 'consolation_final') return position => t('origin-hint.consolation-final', {\n    position\n  }); // Double elimination.\n\n  if (roundNumber === 1) // Grand Final round 1\n    return () => t('origin-hint.grand-final'); // Grand Final round 2 (no hint because it's obvious both participants come from the previous round)\n\n  return undefined;\n}\n\nexports.getFinalOriginHint = getFinalOriginHint;\n/**\n * Returns the label of a match.\n *\n * @param matchNumber Number of the match.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param matchLocation Location of the match.\n */\n\nfunction getMatchLabel(matchNumber, roundNumber, roundCount, matchLocation) {\n  const matchPrefix = matchLocation === 'winner-bracket' ? t('match-label.winner-bracket') : matchLocation === 'loser-bracket' ? t('match-label.loser-bracket') : t('match-label.standard-bracket');\n  const inSemiFinalRound = roundNumber === roundCount - 1;\n  const inFinalRound = roundNumber === roundCount;\n\n  if (matchLocation === 'single-bracket') {\n    if (inSemiFinalRound) return t('match-label.standard-bracket-semi-final', {\n      matchNumber\n    });\n    if (inFinalRound) return t('match-label.standard-bracket-final');\n  }\n\n  if (inSemiFinalRound) return t('match-label.double-elimination-semi-final', {\n    matchPrefix,\n    matchNumber\n  });\n  if (inFinalRound) return t('match-label.double-elimination-final', {\n    matchPrefix\n  });\n  return t('match-label.double-elimination', {\n    matchPrefix,\n    roundNumber,\n    matchNumber\n  });\n}\n\nexports.getMatchLabel = getMatchLabel;\n/**\n * Returns the label of a match in final.\n *\n * @param finalType Type of the final.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\n\nfunction getFinalMatchLabel(finalType, roundNumber, roundCount) {\n  // Single elimination.\n  if (finalType === 'consolation_final') return t('match-label.consolation-final'); // Double elimination.\n\n  if (roundCount === 1) return t('match-label.grand-final-single');\n  return t('match-label.grand-final', {\n    roundNumber\n  });\n}\n\nexports.getFinalMatchLabel = getFinalMatchLabel;\n/**\n * Returns the status of a match.\n *\n * @param status The match status.\n */\n\nfunction getMatchStatus(status) {\n  switch (status) {\n    case brackets_model_1.Status.Locked:\n      return t('match-status.locked');\n\n    case brackets_model_1.Status.Waiting:\n      return t('match-status.waiting');\n\n    case brackets_model_1.Status.Ready:\n      return t('match-status.ready');\n\n    case brackets_model_1.Status.Running:\n      return t('match-status.running');\n\n    case brackets_model_1.Status.Completed:\n      return t('match-status.completed');\n\n    case brackets_model_1.Status.Archived:\n      return t('match-status.archived');\n\n    default:\n      return 'Unknown status';\n  }\n}\n\nexports.getMatchStatus = getMatchStatus;\n/**\n * Returns the name of a group.\n *\n * @param groupNumber Number of the group.\n */\n\nfunction getGroupName(groupNumber) {\n  return t('common.group-name', {\n    groupNumber\n  });\n}\n\nexports.getGroupName = getGroupName;\n/**\n * Returns the name of the bracket.\n *\n * @param stage The current stage.\n * @param type Type of the bracket.\n */\n\nfunction getBracketName(stage, type) {\n  switch (type) {\n    case 'winner-bracket':\n    case 'loser-bracket':\n      return t(`common.group-name-${type}`, {\n        stage\n      });\n\n    default:\n      return undefined;\n  }\n}\n\nexports.getBracketName = getBracketName;\n/**\n * Returns the name of a round.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\n\nfunction getRoundName(roundNumber, roundCount) {\n  return roundNumber === roundCount ? t('common.round-name-final') : t('common.round-name', {\n    roundNumber\n  });\n}\n\nexports.getRoundName = getRoundName;\n/**\n * Returns the name of a round in the winner bracket of a double elimination stage.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\n\nfunction getWinnerBracketRoundName(roundNumber, roundCount) {\n  return roundNumber === roundCount ? t('common.round-name-winner-bracket-final') : t('common.round-name-winner-bracket', {\n    roundNumber\n  });\n}\n\nexports.getWinnerBracketRoundName = getWinnerBracketRoundName;\n/**\n * Returns the name of a round in the loser bracket of a double elimination stage.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\n\nfunction getLoserBracketRoundName(roundNumber, roundCount) {\n  return roundNumber === roundCount ? t('common.round-name-loser-bracket-final') : t('common.round-name-loser-bracket', {\n    roundNumber\n  });\n}\n\nexports.getLoserBracketRoundName = getLoserBracketRoundName;\n\n//# sourceURL=webpack://brackets-viewer/./src/lang.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BracketsViewer = void 0;\n\n__webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n\nconst dom = __importStar(__webpack_require__(/*! ./dom */ \"./src/dom.ts\"));\n\nconst lang = __importStar(__webpack_require__(/*! ./lang */ \"./src/lang.ts\"));\n\nclass BracketsViewer {\n  constructor() {\n    this.participantRefs = {};\n    this.participants = [];\n    this.rounds = [];\n    this.participantImages = [];\n    this.skipFirstRound = false;\n    this.alwaysConnectFirstRound = false; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this._onMatchClick = match => {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._onRoundClick = round => {};\n  }\n  /**\n   * @deprecated\n   * @param callback A callback to be called when a match is clicked.\n   */\n\n\n  set onMatchClicked(callback) {\n    this._onMatchClick = callback;\n  }\n  /**\n   * @deprecated\n   * @param callback A callback to be called when a match is clicked.\n   */\n\n\n  set onRoundClicked(callback) {\n    this._onRoundClick = callback;\n  }\n  /**\n   * Renders data generated with `brackets-manager.js`. If multiple stages are given, they will all be displayed.\n   *\n   * Stages won't be discriminated visually based on the tournament they belong to.\n   *\n   * @param data The data to display.\n   * @param config An optional configuration for the viewer.\n   */\n\n\n  async render(data, config) {\n    const root = document.createDocumentFragment();\n    this.config = {\n      participantOriginPlacement: (config === null || config === void 0 ? void 0 : config.participantOriginPlacement) || 'before',\n      separatedChildCountLabel: (config === null || config === void 0 ? void 0 : config.separatedChildCountLabel) !== undefined ? config.separatedChildCountLabel : false,\n      showSlotsOrigin: (config === null || config === void 0 ? void 0 : config.showSlotsOrigin) !== undefined ? config.showSlotsOrigin : true,\n      showLowerBracketSlotsOrigin: (config === null || config === void 0 ? void 0 : config.showLowerBracketSlotsOrigin) !== undefined ? config.showLowerBracketSlotsOrigin : true,\n      highlightParticipantOnHover: (config === null || config === void 0 ? void 0 : config.highlightParticipantOnHover) !== undefined ? config.highlightParticipantOnHover : true\n    };\n    if (this.config.onMatchClick) this._onMatchClick = this.config.onMatchClick;\n    if (this.config.onRoundClick) this._onRoundClick = this.config.onRoundClick;\n    this.participants = data.participants;\n    this.rounds = data.rounds;\n    data.participants.forEach(participant => this.participantRefs[participant.id] = []);\n    data.stages.forEach(stage => this.renderStage(root, { ...data,\n      stages: [stage],\n      matches: data.matches.filter(match => match.stage_id === stage.id)\n    }));\n    (0, helpers_1.findRoot)(config === null || config === void 0 ? void 0 : config.selector).append(root);\n  }\n  /**\n   * Updates the results of an existing match.\n   *\n   * @param match The match to update.\n   */\n\n\n  updateMatch(match) {\n    //  TODO: finish this function (update win/loss/forfeit, scoreboard in round-robin, etc.)\n    var _a, _b, _c, _d, _e, _f;\n\n    const matchContainer = document.querySelector(`[data-match-id='${match.id}']`);\n    if (!matchContainer) throw Error('Match not found.');\n    matchContainer.setAttribute('data-match-status', match.status.toString());\n    const result1 = matchContainer.querySelector('.participant:nth-of-type(1) .result');\n    if (result1 && ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.score)) result1.innerHTML = (_c = (_b = match.opponent1) === null || _b === void 0 ? void 0 : _b.score) === null || _c === void 0 ? void 0 : _c.toString();\n    const result2 = matchContainer.querySelector('.participant:nth-of-type(2) .result');\n    if (result2 && ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.score)) result2.innerHTML = (_f = (_e = match.opponent2) === null || _e === void 0 ? void 0 : _e.score) === null || _f === void 0 ? void 0 : _f.toString();\n  }\n  /**\n   * Updates the results of an existing match.\n   *\n   * @param match The match to update.\n   */\n\n\n  updateRound(round) {\n    //  TODO: finish this function (update win/loss/forfeit, scoreboard in round-robin, etc.)\n    const roundContainer = document.querySelector(`[data-round-id='${round.id}']`);\n    if (!roundContainer) throw Error('Round not found.');\n    const title = roundContainer.querySelector('h3');\n    if (title && round.title) title.innerHTML = round.title; // matchContainer.setAttribute('data-match-status', match.status.toString());\n    // const result1 = matchContainer.querySelector('.participant:nth-of-type(1) .result');\n    // if (result1 && match.opponent1?.score) result1.innerHTML = match.opponent1?.score?.toString();\n    // const result2 = matchContainer.querySelector('.participant:nth-of-type(2) .result');\n    // if (result2 && match.opponent2?.score) result2.innerHTML = match.opponent2?.score?.toString();\n  }\n  /**\n   * Sets the images which will be rendered for every participant.\n   *\n   * @param images The participant images.\n   */\n\n\n  setParticipantImages(images) {\n    this.participantImages = images;\n  }\n  /**\n   * Adds a locale to the available i18n bundles.\n   *\n   * @param name Name of the locale.\n   * @param locale Contents of the locale.\n   */\n\n\n  addLocale(name, locale) {\n    lang.addLocale(name, locale);\n  }\n  /**\n   * Renders a stage (round-robin, single or double elimination).\n   *\n   * @param root The root element.\n   * @param data The data to display.\n   */\n\n\n  renderStage(root, data) {\n    const stage = data.stages[0];\n    const matchesByGroup = (0, helpers_1.splitBy)(data.matches, 'group_id');\n    this.stage = stage;\n    this.skipFirstRound = stage.settings.skipFirstRound || false;\n\n    switch (stage.type) {\n      case 'round_robin':\n        this.renderRoundRobin(root, stage, matchesByGroup);\n        break;\n\n      case 'single_elimination':\n      case 'double_elimination':\n        this.renderElimination(root, stage, matchesByGroup);\n        break;\n\n      default:\n        throw Error(`Unknown bracket type: ${stage.type}`);\n    }\n  }\n  /**\n   * Renders a round-robin stage.\n   *\n   * @param root The root element.\n   * @param stage The stage to render.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderRoundRobin(root, stage, matchesByGroup) {\n    const container = dom.createRoundRobinContainer(stage.id);\n    container.append(dom.createTitle(stage.name));\n    let groupNumber = 1;\n\n    for (const groupMatches of matchesByGroup) {\n      const groupId = groupMatches[0].group_id;\n      const groupContainer = dom.createGroupContainer(groupId, lang.getGroupName(groupNumber++));\n      const matchesByRound = (0, helpers_1.splitBy)(groupMatches, 'round_id');\n      let roundNumber = 1;\n\n      for (const roundMatches of matchesByRound) {\n        const roundId = roundMatches[0].round_id;\n        const roundContainer = dom.createRoundContainer(roundId, lang.getRoundName(roundNumber++, 0));\n\n        for (const match of roundMatches) roundContainer.append(this.createMatch(match));\n\n        groupContainer.append(roundContainer);\n      }\n\n      groupContainer.append(this.createRanking(groupMatches));\n      container.append(groupContainer);\n    }\n\n    root.append(container);\n  }\n  /**\n   * Renders an elimination stage (single or double).\n   *\n   * @param root The root element.\n   * @param stage The stage to render.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderElimination(root, stage, matchesByGroup) {\n    const container = dom.createEliminationContainer(stage.id);\n    container.append(dom.createTitle(stage.name));\n    if (stage.type === 'single_elimination') this.renderSingleElimination(container, matchesByGroup);else this.renderDoubleElimination(container, matchesByGroup);\n    root.append(container);\n  }\n  /**\n   * Renders a single elimination stage.\n   *\n   * @param container The container to render into.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderSingleElimination(container, matchesByGroup) {\n    const hasFinal = matchesByGroup[1] !== undefined;\n    this.renderBracket(container, (0, helpers_1.splitBy)(matchesByGroup[0], 'round_id'), lang.getRoundName, 'single-bracket');\n    if (hasFinal) this.renderFinal(container, 'consolation_final', matchesByGroup[1]);\n  }\n  /**\n   * Renders a double elimination stage.\n   *\n   * @param container The container to render into.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderDoubleElimination(container, matchesByGroup) {\n    const hasLoserBracket = matchesByGroup[1] !== undefined;\n    const hasFinal = matchesByGroup[2] !== undefined;\n    this.renderBracket(container, (0, helpers_1.splitBy)(matchesByGroup[0], 'round_id'), lang.getWinnerBracketRoundName, 'winner-bracket', hasFinal);\n    if (hasLoserBracket) this.renderBracket(container, (0, helpers_1.splitBy)(matchesByGroup[1], 'round_id'), lang.getLoserBracketRoundName, 'loser-bracket');\n    if (hasFinal) this.renderFinal(container, 'grand_final', matchesByGroup[2]);\n  }\n  /**\n   * Renders a bracket.\n   *\n   * @param container The container to render into.\n   * @param matchesByRound A list of matches for each round.\n   * @param roundName A function giving a round's name based on its number.\n   * @param bracketType Type of the bracket.\n   * @param connectFinal Whether to connect the last match of the bracket to the final.\n   */\n\n\n  renderBracket(container, matchesByRound, roundName, bracketType, connectFinal) {\n    var _a, _b;\n\n    const groupId = matchesByRound[0][0].group_id;\n    const roundCount = matchesByRound.length;\n    const bracketContainer = dom.createBracketContainer(groupId, lang.getBracketName(this.stage, bracketType));\n    const roundsContainer = dom.createRoundsContainer();\n    const {\n      matches: completedMatches,\n      fromToornament\n    } = (0, helpers_1.completeWithBlankMatches)(bracketType, matchesByRound[0], matchesByRound[1]);\n    this.alwaysConnectFirstRound = !fromToornament;\n\n    for (let roundIndex = 0; roundIndex < matchesByRound.length; roundIndex++) {\n      const roundId = matchesByRound[roundIndex][0].round_id;\n      const roundNumber = roundIndex + 1;\n      const round = (_a = this.rounds.find(round => round.id === roundId)) !== null && _a !== void 0 ? _a : {\n        id: roundId,\n        stage_id: 1,\n        group_id: 1,\n        number: roundNumber,\n        title: \"\"\n      };\n      const title = (_b = round.title) !== null && _b !== void 0 ? _b : roundName(roundNumber, roundCount);\n      const roundContainer = dom.createRoundContainer(roundId, title, () => this._onRoundClick(round));\n      const roundMatches = fromToornament && roundNumber === 1 ? completedMatches : matchesByRound[roundIndex];\n\n      for (const match of roundMatches) roundContainer.append(match && this.createBracketMatch(roundNumber, roundCount, match, bracketType, connectFinal) || this.skipBracketMatch());\n\n      roundsContainer.append(roundContainer);\n    }\n\n    bracketContainer.append(roundsContainer);\n    container.append(bracketContainer);\n  }\n  /**\n   * Renders a final group.\n   *\n   * @param container The container to render into.\n   * @param finalType Type of the final.\n   * @param matches Matches of the final.\n   */\n\n\n  renderFinal(container, finalType, matches) {\n    var _a, _b;\n\n    const upperBracket = container.querySelector('.bracket .rounds');\n    if (!upperBracket) throw Error('Upper bracket not found.');\n    const winnerWb = matches[0].opponent1;\n    const displayCount = (winnerWb === null || winnerWb === void 0 ? void 0 : winnerWb.id) === null || (winnerWb === null || winnerWb === void 0 ? void 0 : winnerWb.result) === 'win' ? 1 : 2;\n    const finalMatches = matches.slice(0, displayCount);\n    const roundCount = matches.length;\n\n    for (let roundIndex = 0; roundIndex < finalMatches.length; roundIndex++) {\n      const roundNumber = roundIndex + 1;\n      const roundId = finalMatches[roundIndex].round_id;\n      const round = (_a = this.rounds.find(round => round.id === roundId)) !== null && _a !== void 0 ? _a : {\n        id: roundId,\n        stage_id: 1,\n        group_id: 1,\n        number: roundNumber,\n        title: \"\"\n      };\n      const title = (_b = round.title) !== null && _b !== void 0 ? _b : lang.getFinalMatchLabel(finalType, roundNumber, roundCount);\n      const roundContainer = dom.createRoundContainer(finalMatches[roundIndex].round_id, title);\n      roundContainer.append(this.createFinalMatch(finalType, finalMatches, roundNumber, roundCount));\n      upperBracket.append(roundContainer);\n    }\n  }\n  /**\n   * Creates a ranking table based on matches of a round-robin stage.\n   *\n   * @param matches The list of matches.\n   */\n\n\n  createRanking(matches) {\n    const table = dom.createTable();\n    const ranking = (0, helpers_1.getRanking)(matches);\n    table.append(dom.createRankingHeaders(ranking));\n\n    for (const item of ranking) table.append(this.createRankingRow(item));\n\n    return table;\n  }\n  /**\n   * Creates a row of the ranking table.\n   *\n   * @param item Item of the ranking.\n   */\n\n\n  createRankingRow(item) {\n    const row = dom.createRow();\n    const notRanked = item.played === 0;\n\n    for (const key in item) {\n      const prop = key;\n      const data = item[prop];\n\n      if (prop === 'id') {\n        const participant = this.participants.find(participant => participant.id === data);\n\n        if (participant !== undefined) {\n          const cell = dom.createCell(participant.name);\n          this.setupMouseHover(participant.id, cell);\n          row.append(cell);\n          continue;\n        }\n      }\n\n      if (notRanked && (prop === 'rank' || prop === 'points')) {\n        row.append(dom.createCell('-'));\n        continue;\n      }\n\n      row.append(dom.createCell(data));\n    }\n\n    return row;\n  }\n  /**\n   * Creates a match in a bracket.\n   *\n   * @param roundNumber Number of the round.\n   * @param roundCount Count of rounds.\n   * @param match Information about the match.\n   * @param matchLocation Location of the match.\n   * @param connectFinal Whether to connect this match to the final if it happens to be the last one of the bracket.\n   */\n\n\n  createBracketMatch(roundNumber, roundCount, match, matchLocation, connectFinal) {\n    const connection = dom.getBracketConnection(this.alwaysConnectFirstRound, roundNumber, roundCount, match, matchLocation, connectFinal);\n    const matchLabel = lang.getMatchLabel(match.number, roundNumber, roundCount, matchLocation);\n    const originHint = lang.getOriginHint(roundNumber, roundCount, this.skipFirstRound, matchLocation);\n    return this.createMatch(match, matchLocation, connection, matchLabel, originHint, roundNumber);\n  }\n  /**\n   * Creates a match in a final.\n   *\n   * @param type Type of the final.\n   * @param matches Matches of the final.\n   * @param roundNumber Number of the round.\n   * @param roundCount Count of rounds.\n   */\n\n\n  createFinalMatch(type, matches, roundNumber, roundCount) {\n    const roundIndex = roundNumber - 1;\n    const connection = dom.getFinalConnection(type, roundNumber, matches.length);\n    const matchLabel = lang.getFinalMatchLabel(type, roundNumber, roundCount);\n    const originHint = lang.getFinalOriginHint(type, roundNumber);\n    return this.createMatch(matches[roundIndex], 'final-group', connection, matchLabel, originHint);\n  }\n  /**\n   * Creates a hidden empty match to act as a placeholder.\n   */\n\n\n  skipBracketMatch() {\n    const matchContainer = dom.createMatchContainer();\n    const opponents = dom.createOpponentsContainer();\n    const participant1 = this.createParticipant(null);\n    const participant2 = this.createParticipant(null);\n    opponents.append(participant1, participant2);\n    matchContainer.append(opponents);\n    matchContainer.style.visibility = 'hidden';\n    return matchContainer;\n  }\n  /**\n   * Creates a match based on its results.\n   *\n   * @param match Results of the match.\n   * @param matchLocation Location of the match.\n   * @param connection Connection of this match with the others.\n   * @param label Label of the match.\n   * @param originHint Origin hint for the match.\n   * @param roundNumber Number of the round.\n   */\n\n\n  createMatch(match, matchLocation, connection, label, originHint, roundNumber) {\n    const matchContainer = dom.createMatchContainer(match.id, match.status);\n    const opponents = dom.createOpponentsContainer(() => this._onMatchClick(match));\n    if (match.status >= brackets_model_1.Status.Completed) originHint = undefined;\n    const participant1 = this.createParticipant(match.opponent1, 'opponent1', originHint, matchLocation, roundNumber);\n    const participant2 = this.createParticipant(match.opponent2, 'opponent2', originHint, matchLocation, roundNumber);\n    this.renderMatchLabel(opponents, match, label);\n    opponents.append(participant1, participant2);\n    matchContainer.append(opponents);\n    if (!connection) return matchContainer;\n    dom.setupConnection(opponents, matchContainer, connection);\n    return matchContainer;\n  }\n  /**\n   * Creates a participant for a match.\n   *\n   * @param participant Information about the participant.\n   * @param side Side of the participant.\n   * @param originHint Origin hint for the match.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n\n\n  createParticipant(participant, side, originHint, matchLocation, roundNumber) {\n    const containers = {\n      participant: dom.createParticipantContainer(participant && participant.id),\n      name: dom.createNameContainer(),\n      result: dom.createResultContainer()\n    };\n    if (participant === null || participant === undefined) dom.setupBye(containers.name);else this.renderParticipant(containers, participant, side, originHint, matchLocation, roundNumber);\n    containers.participant.append(containers.name, containers.result);\n    if (participant && participant.id !== null) this.setupMouseHover(participant.id, containers.participant);\n    return containers.participant;\n  }\n  /**\n   * Renders a participant.\n   *\n   * @param containers Containers for the participant.\n   * @param participant The participant result.\n   * @param side Side of the participant.\n   * @param originHint Origin hint for the match.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n\n\n  renderParticipant(containers, participant, side, originHint, matchLocation, roundNumber) {\n    const found = this.participants.find(item => item.id === participant.id);\n\n    if (found) {\n      containers.name.innerText = found.name;\n      containers.participant.setAttribute('title', found.name);\n      this.renderParticipantImage(containers.name, found.id);\n      this.renderParticipantOrigin(containers.name, participant, side, matchLocation, roundNumber);\n    } else this.renderHint(containers.name, participant, originHint, matchLocation);\n\n    containers.result.innerText = `${participant.score === undefined ? '-' : participant.score}`;\n    dom.setupWin(containers.participant, containers.result, participant);\n    dom.setupLoss(containers.participant, containers.result, participant);\n  }\n  /**\n   * Renders a participant image.\n   *\n   * @param nameContainer The name container.\n   * @param participantId ID of the participant.\n   */\n\n\n  renderParticipantImage(nameContainer, participantId) {\n    const found = this.participantImages.find(item => item.participantId === participantId);\n    if (found) dom.addParticipantImage(nameContainer, found.imageUrl);\n  }\n  /**\n   * Renders a match label.\n   *\n   * @param opponents The opponents container.\n   * @param match Results of the match.\n   * @param label Label of the match.\n   */\n\n\n  renderMatchLabel(opponents, match, label) {\n    const childCountLabel = `Bo${match.child_count}`;\n    label = label || '';\n\n    if (this.config.separatedChildCountLabel) {\n      opponents.append(dom.createMatchLabel(label, lang.getMatchStatus(match.status)));\n      if (match.child_count > 0) opponents.append(dom.createChildCountLabel(lang.t('common.best-of-x', {\n        x: match.child_count\n      })));\n      return;\n    }\n\n    if (match.child_count > 0) {\n      const joined = label ? `${label}, ${childCountLabel}` : childCountLabel;\n      opponents.append(dom.createMatchLabel(joined, lang.getMatchStatus(match.status)));\n    }\n  }\n  /**\n   * Renders an origin hint for a participant.\n   *\n   * @param nameContainer The name container.\n   * @param participant The participant result.\n   * @param originHint Origin hint for the participant.\n   * @param matchLocation Location of the match.\n   */\n\n\n  renderHint(nameContainer, participant, originHint, matchLocation) {\n    if (originHint === undefined || participant.position === undefined) return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && matchLocation === 'loser-bracket') return;\n    dom.setupHint(nameContainer, originHint(participant.position));\n  }\n  /**\n   * Renders a participant's origin.\n   *\n   * @param nameContainer The name container.\n   * @param participant The participant result.\n   * @param side Side of the participant.Side of the participant.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n\n\n  renderParticipantOrigin(nameContainer, participant, side, matchLocation, roundNumber) {\n    if (participant.position === undefined || matchLocation === undefined) return;\n    if (!this.config.participantOriginPlacement || this.config.participantOriginPlacement === 'none') return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && matchLocation === 'loser-bracket') return;\n    const abbreviation = (0, helpers_1.getOriginAbbreviation)(matchLocation, this.skipFirstRound, roundNumber, side);\n    if (!abbreviation) return;\n    const origin = abbreviation + participant.position;\n    dom.addParticipantOrigin(nameContainer, origin, this.config.participantOriginPlacement);\n  }\n  /**\n   * Sets mouse hover events for a participant.\n   *\n   * @param participantId ID of the participant.\n   * @param element The dom element to add events to.\n   */\n\n\n  setupMouseHover(participantId, element) {\n    if (!this.config.highlightParticipantOnHover) return;\n    const refs = this.participantRefs[participantId];\n    if (!refs) throw Error(`The participant (id: ${participantId}) does not exist in the participants table.`);\n    refs.push(element);\n    element.addEventListener('mouseover', () => {\n      refs.forEach(el => el.classList.add('hover'));\n    });\n    element.addEventListener('mouseleave', () => {\n      refs.forEach(el => el.classList.remove('hover'));\n    });\n  }\n\n}\n\nexports.BracketsViewer = BracketsViewer;\n\n//# sourceURL=webpack://brackets-viewer/./src/main.ts?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/base/getter.js":
/*!***********************************************************!*\
  !*** ./node_modules/brackets-manager/dist/base/getter.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseGetter = void 0;\nconst helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass BaseGetter {\n    /**\n     * Creates an instance of a Storage getter.\n     *\n     * @param storage The implementation of Storage.\n     */\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /**\n     * Gets all the rounds that contain ordered participants.\n     *\n     * @param stage The stage to get rounds from.\n     */\n    async getOrderedRounds(stage) {\n        if (!(stage === null || stage === void 0 ? void 0 : stage.settings.size))\n            throw Error('The stage has no size.');\n        if (stage.type === 'single_elimination')\n            return this.getOrderedRoundsSingleElimination(stage.id);\n        return this.getOrderedRoundsDoubleElimination(stage.id);\n    }\n    /**\n     * Gets all the rounds that contain ordered participants in a single elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getOrderedRoundsSingleElimination(stageId) {\n        return [await this.getUpperBracketFirstRound(stageId)];\n    }\n    /**\n     * Gets all the rounds that contain ordered participants in a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getOrderedRoundsDoubleElimination(stageId) {\n        // Getting all rounds instead of cherry-picking them is the least expensive.\n        const rounds = await this.storage.select('round', { stage_id: stageId });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const loserBracket = await this.getLoserBracket(stageId);\n        if (!loserBracket)\n            throw Error('Loser bracket not found.');\n        const firstRoundWB = rounds[0];\n        const roundsLB = rounds.filter(r => r.group_id === loserBracket.id);\n        const orderedRoundsLB = roundsLB.filter(r => helpers.isOrderingSupportedLoserBracket(r.number, roundsLB.length));\n        return [firstRoundWB, ...orderedRoundsLB];\n    }\n    /**\n     * Gets the positional information (number in group and total number of rounds in group) of a round based on its id.\n     *\n     * @param roundId ID of the round.\n     */\n    async getRoundPositionalInfo(roundId) {\n        const round = await this.storage.select('round', roundId);\n        if (!round)\n            throw Error('Round not found.');\n        const rounds = await this.storage.select('round', { group_id: round.group_id });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        return {\n            roundNumber: round.number,\n            roundCount: rounds.length,\n        };\n    }\n    /**\n     * Gets the matches leading to the given match.\n     *\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async getPreviousMatches(match, matchLocation, stage, roundNumber) {\n        if (matchLocation === 'loser_bracket')\n            return this.getPreviousMatchesLB(match, stage, roundNumber);\n        if (matchLocation === 'final_group')\n            return this.getPreviousMatchesFinal(match, roundNumber);\n        if (roundNumber === 1)\n            return []; // The match is in the first round of an upper bracket.\n        return this.getMatchesBeforeMajorRound(match, roundNumber);\n    }\n    /**\n     * Gets the matches leading to the given match, which is in a final group (consolation final or grand final).\n     *\n     * @param match The current match.\n     * @param roundNumber Number of the current round.\n     */\n    async getPreviousMatchesFinal(match, roundNumber) {\n        if (roundNumber > 1)\n            return [await this.findMatch(match.group_id, roundNumber - 1, 1)];\n        const upperBracket = await this.getUpperBracket(match.stage_id);\n        const lastRound = await this.getLastRound(upperBracket.id);\n        const upperBracketFinalMatch = await this.storage.selectFirst('match', {\n            round_id: lastRound.id,\n            number: 1,\n        });\n        if (upperBracketFinalMatch === null)\n            throw Error('Match not found.');\n        return [upperBracketFinalMatch];\n    }\n    /**\n     * Gets the matches leading to a given match from the loser bracket.\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async getPreviousMatchesLB(match, stage, roundNumber) {\n        if (stage.settings.skipFirstRound && roundNumber === 1)\n            return [];\n        if (helpers.hasBye(match))\n            return []; // Shortcut because we are coming from propagateByes().\n        const winnerBracket = await this.getUpperBracket(match.stage_id);\n        const actualRoundNumberWB = Math.ceil((roundNumber + 1) / 2);\n        const roundNumberWB = stage.settings.skipFirstRound ? actualRoundNumberWB - 1 : actualRoundNumberWB;\n        if (roundNumber === 1)\n            return this.getMatchesBeforeFirstRoundLB(match, winnerBracket.id, roundNumberWB);\n        if (roundNumber % 2 === 0)\n            return this.getMatchesBeforeMinorRoundLB(match, winnerBracket.id, roundNumber, roundNumberWB);\n        return this.getMatchesBeforeMajorRound(match, roundNumber);\n    }\n    /**\n     * Gets the matches leading to a given match in a major round (every round of upper bracket or specific ones in lower bracket).\n     *\n     * @param match The current match.\n     * @param roundNumber Number of the round.\n     */\n    async getMatchesBeforeMajorRound(match, roundNumber) {\n        return [\n            await this.findMatch(match.group_id, roundNumber - 1, match.number * 2 - 1),\n            await this.findMatch(match.group_id, roundNumber - 1, match.number * 2),\n        ];\n    }\n    /**\n     * Gets the matches leading to a given match in the first round of the loser bracket.\n     *\n     * @param match The current match.\n     * @param winnerBracketId ID of the winner bracket.\n     * @param roundNumberWB The number of the previous round in the winner bracket.\n     */\n    async getMatchesBeforeFirstRoundLB(match, winnerBracketId, roundNumberWB) {\n        return [\n            await this.findMatch(winnerBracketId, roundNumberWB, helpers.getOriginPosition(match, 'opponent1')),\n            await this.findMatch(winnerBracketId, roundNumberWB, helpers.getOriginPosition(match, 'opponent2')),\n        ];\n    }\n    /**\n     * Gets the matches leading to a given match in a minor round of the loser bracket.\n     *\n     * @param match The current match.\n     * @param winnerBracketId ID of the winner bracket.\n     * @param roundNumber Number of the current round.\n     * @param roundNumberWB The number of the previous round in the winner bracket.\n     */\n    async getMatchesBeforeMinorRoundLB(match, winnerBracketId, roundNumber, roundNumberWB) {\n        const matchNumber = helpers.getOriginPosition(match, 'opponent1');\n        return [\n            await this.findMatch(winnerBracketId, roundNumberWB, matchNumber),\n            await this.findMatch(match.group_id, roundNumber - 1, match.number),\n        ];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match will go just after.\n     *\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatches(match, matchLocation, stage, roundNumber, roundCount) {\n        switch (matchLocation) {\n            case 'single_bracket':\n                return this.getNextMatchesUpperBracket(match, stage.type, roundNumber, roundCount);\n            case 'winner_bracket':\n                return this.getNextMatchesWB(match, stage, roundNumber, roundCount);\n            case 'loser_bracket':\n                return this.getNextMatchesLB(match, stage.type, roundNumber, roundCount);\n            case 'final_group':\n                return this.getNextMatchesFinal(match, roundNumber, roundCount);\n            default:\n                throw Error('Unknown bracket kind.');\n        }\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of winner bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesWB(match, stage, roundNumber, roundCount) {\n        const loserBracket = await this.getLoserBracket(match.stage_id);\n        if (loserBracket === null) // Only one match in the stage, there is no loser bracket.\n            return [];\n        const actualRoundNumber = stage.settings.skipFirstRound ? roundNumber + 1 : roundNumber;\n        const roundNumberLB = actualRoundNumber > 1 ? (actualRoundNumber - 1) * 2 : 1;\n        const participantCount = stage.settings.size;\n        const method = helpers.getLoserOrdering(stage.settings.seedOrdering, roundNumberLB);\n        const actualMatchNumberLB = helpers.findLoserMatchNumber(participantCount, roundNumberLB, match.number, method);\n        return [\n            ...await this.getNextMatchesUpperBracket(match, stage.type, roundNumber, roundCount),\n            await this.findMatch(loserBracket.id, roundNumberLB, actualMatchNumberLB),\n        ];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of an upper bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesUpperBracket(match, stageType, roundNumber, roundCount) {\n        if (stageType === 'single_elimination')\n            return this.getNextMatchesUpperBracketSingleElimination(match, stageType, roundNumber, roundCount);\n        if (stageType === 'double_elimination' && roundNumber === roundCount)\n            return [await this.getFirstMatchFinal(match, stageType)];\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of the unique bracket of a single elimination will go just after.\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesUpperBracketSingleElimination(match, stageType, roundNumber, roundCount) {\n        if (roundNumber === roundCount - 1) {\n            const final = await this.getFirstMatchFinal(match, stageType);\n            return [\n                await this.getDiagonalMatch(match.group_id, roundNumber, match.number),\n                ...final ? [final] : [],\n            ];\n        }\n        if (roundNumber === roundCount)\n            return [];\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of loser bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesLB(match, stageType, roundNumber, roundCount) {\n        if (roundNumber === roundCount) {\n            const final = await this.getFirstMatchFinal(match, stageType);\n            return final ? [final] : [];\n        }\n        if (roundNumber % 2 === 1)\n            return this.getMatchAfterMajorRoundLB(match, roundNumber);\n        return this.getMatchAfterMinorRoundLB(match, roundNumber);\n    }\n    /**\n     * Gets the first match of the final group (consolation final or grand final).\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     */\n    async getFirstMatchFinal(match, stageType) {\n        const finalGroupId = await this.getFinalGroupId(match.stage_id, stageType);\n        if (finalGroupId === null)\n            return null;\n        return this.findMatch(finalGroupId, 1, 1);\n    }\n    /**\n     * Gets the matches following the current match, which is in the final group (consolation final or grand final).\n     *\n     * @param match The current match.\n     * @param roundNumber The number of the current round.\n     * @param roundCount The count of rounds.\n     */\n    async getNextMatchesFinal(match, roundNumber, roundCount) {\n        if (roundNumber === roundCount)\n            return [];\n        return [await this.findMatch(match.group_id, roundNumber + 1, 1)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of a winner bracket's major round will go just after.\n     *\n     * @param match The current match.\n     * @param roundNumber The number of the current round.\n     */\n    async getMatchAfterMajorRoundLB(match, roundNumber) {\n        return [await this.getParallelMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of a winner bracket's minor round will go just after.\n     *\n     * @param match The current match.\n     * @param roundNumber The number of the current round.\n     */\n    async getMatchAfterMinorRoundLB(match, roundNumber) {\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Returns the good seeding ordering based on the stage's type.\n     *\n     * @param stageType The type of the stage.\n     * @param create A reference to a Create instance.\n     */\n    static getSeedingOrdering(stageType, create) {\n        return stageType === 'round_robin' ? create.getRoundRobinOrdering() : create.getStandardBracketFirstRoundOrdering();\n    }\n    /**\n     * Returns the matches which contain the seeding of a stage based on its type.\n     *\n     * @param stageId ID of the stage.\n     * @param stageType The type of the stage.\n     */\n    async getSeedingMatches(stageId, stageType) {\n        if (stageType === 'round_robin')\n            return this.storage.select('match', { stage_id: stageId });\n        const firstRound = await this.getUpperBracketFirstRound(stageId);\n        return this.storage.select('match', { round_id: firstRound.id });\n    }\n    /**\n     * Gets the first round of the upper bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getUpperBracketFirstRound(stageId) {\n        // Considering the database is ordered, this round will always be the first round of the upper bracket.\n        const firstRound = await this.storage.selectFirst('round', { stage_id: stageId, number: 1 });\n        if (!firstRound)\n            throw Error('Round not found.');\n        return firstRound;\n    }\n    /**\n     * Gets the last round of a group.\n     *\n     * @param groupId ID of the group.\n     */\n    async getLastRound(groupId) {\n        const round = await this.storage.selectLast('round', { group_id: groupId });\n        if (!round)\n            throw Error('Error getting rounds.');\n        return round;\n    }\n    /**\n     * Returns the id of the final group (consolation final or grand final).\n     *\n     * @param stageId ID of the stage.\n     * @param stageType Type of the stage.\n     */\n    async getFinalGroupId(stageId, stageType) {\n        const groupNumber = stageType === 'single_elimination' ? 2 /* Consolation final */ : 3 /* Grand final */;\n        const finalGroup = await this.storage.selectFirst('group', { stage_id: stageId, number: groupNumber });\n        if (!finalGroup)\n            return null;\n        return finalGroup.id;\n    }\n    /**\n     * Gets the upper bracket (the only bracket if single elimination or the winner bracket in double elimination).\n     *\n     * @param stageId ID of the stage.\n     */\n    async getUpperBracket(stageId) {\n        const winnerBracket = await this.storage.selectFirst('group', { stage_id: stageId, number: 1 });\n        if (!winnerBracket)\n            throw Error('Winner bracket not found.');\n        return winnerBracket;\n    }\n    /**\n     * Gets the loser bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getLoserBracket(stageId) {\n        return this.storage.selectFirst('group', { stage_id: stageId, number: 2 });\n    }\n    /**\n     * Gets the corresponding match in the next round (\"diagonal match\") the usual way.\n     *\n     * Just like from Round 1 to Round 2 in a single elimination stage.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async getDiagonalMatch(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber + 1, helpers.getDiagonalMatchNumber(matchNumber));\n    }\n    /**\n     * Gets the corresponding match in the next round (\"parallel match\") the \"major round to minor round\" way.\n     *\n     * Just like from Round 1 to Round 2 in the loser bracket of a double elimination stage.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async getParallelMatch(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber + 1, matchNumber);\n    }\n    /**\n     * Finds a match in a given group. The match must have the given number in a round of which the number in group is given.\n     *\n     * **Example:** In group of id 1, give me the 4th match in the 3rd round.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async findMatch(groupId, roundNumber, matchNumber) {\n        const round = await this.storage.selectFirst('round', {\n            group_id: groupId,\n            number: roundNumber,\n        });\n        if (!round)\n            throw Error('Round not found.');\n        const match = await this.storage.selectFirst('match', {\n            round_id: round.id,\n            number: matchNumber,\n        });\n        if (!match)\n            throw Error('Match not found.');\n        return match;\n    }\n    /**\n     * Finds a match game based on its `id` or based on the combination of its `parent_id` and `number`.\n     *\n     * @param game Values to change in a match game.\n     */\n    async findMatchGame(game) {\n        if (game.id !== undefined) {\n            const stored = await this.storage.select('match_game', game.id);\n            if (!stored)\n                throw Error('Match game not found.');\n            return stored;\n        }\n        if (game.parent_id !== undefined && game.number) {\n            const stored = await this.storage.selectFirst('match_game', {\n                parent_id: game.parent_id,\n                number: game.number,\n            });\n            if (!stored)\n                throw Error('Match game not found.');\n            return stored;\n        }\n        throw Error('No match game id nor parent id and number given.');\n    }\n}\nexports.BaseGetter = BaseGetter;\n//# sourceMappingURL=getter.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/base/getter.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/base/updater.js":
/*!************************************************************!*\
  !*** ./node_modules/brackets-manager/dist/base/updater.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseUpdater = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ../ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst create_1 = __webpack_require__(/*! ../create */ \"./node_modules/brackets-manager/dist/create.js\");\nconst getter_1 = __webpack_require__(/*! ./getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst get_1 = __webpack_require__(/*! ../get */ \"./node_modules/brackets-manager/dist/get.js\");\nconst helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass BaseUpdater extends getter_1.BaseGetter {\n    /**\n     * Updates or resets the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seeding A new seeding or null to reset the existing seeding.\n     */\n    async updateSeeding(stageId, seeding) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        const create = new create_1.Create(this.storage, {\n            name: stage.name,\n            tournamentId: stage.tournament_id,\n            type: stage.type,\n            settings: stage.settings,\n            seeding: seeding || undefined,\n        });\n        create.setExisting(stageId, false);\n        const method = getter_1.BaseGetter.getSeedingOrdering(stage.type, create);\n        const slots = await create.getSlots();\n        const matches = await this.getSeedingMatches(stage.id, stage.type);\n        if (!matches)\n            throw Error('Error getting matches associated to the seeding.');\n        const ordered = ordering_1.ordering[method](slots);\n        await BaseUpdater.assertCanUpdateSeeding(matches, ordered);\n        await create.run();\n    }\n    /**\n     * Confirms the current seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async confirmCurrentSeeding(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        const get = new get_1.Get(this.storage);\n        const currentSeeding = await get.seeding(stageId);\n        const newSeeding = helpers.convertSlotsToSeeding(currentSeeding.map(helpers.convertTBDtoBYE));\n        const create = new create_1.Create(this.storage, {\n            name: stage.name,\n            tournamentId: stage.tournament_id,\n            type: stage.type,\n            settings: stage.settings,\n            seeding: newSeeding,\n        });\n        create.setExisting(stageId, true);\n        await create.run();\n    }\n    /**\n     * Updates a parent match based on its child games.\n     *\n     * @param parentId ID of the parent match.\n     * @param inRoundRobin Indicates whether the parent match is in a round-robin stage.\n     */\n    async updateParentMatch(parentId, inRoundRobin) {\n        const storedParent = await this.storage.select('match', parentId);\n        if (!storedParent)\n            throw Error('Parent not found.');\n        const games = await this.storage.select('match_game', { parent_id: parentId });\n        if (!games)\n            throw Error('No match games.');\n        const parentScores = helpers.getChildGamesResults(games);\n        const parent = helpers.getParentMatchResults(storedParent, parentScores);\n        helpers.setParentMatchCompleted(parent, storedParent.child_count, inRoundRobin);\n        await this.updateMatch(storedParent, parent, true);\n    }\n    /**\n     * Throws an error if a match is locked and the new seeding will change this match's participants.\n     *\n     * @param matches The matches stored in the database.\n     * @param slots The slots to check from the new seeding.\n     */\n    static async assertCanUpdateSeeding(matches, slots) {\n        var _a, _b;\n        let index = 0;\n        for (const match of matches) {\n            const opponent1 = slots[index++];\n            const opponent2 = slots[index++];\n            const locked = helpers.isMatchParticipantLocked(match);\n            if (!locked)\n                continue;\n            if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id) !== (opponent1 === null || opponent1 === void 0 ? void 0 : opponent1.id) || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id) !== (opponent2 === null || opponent2 === void 0 ? void 0 : opponent2.id))\n                throw Error('A match is locked.');\n        }\n    }\n    /**\n     * Updates the matches related (previous and next) to a match.\n     *\n     * @param match A match.\n     * @param updatePrevious Whether to update the previous matches.\n     * @param updateNext Whether to update the next matches.\n     */\n    async updateRelatedMatches(match, updatePrevious, updateNext) {\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(match.round_id);\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        updatePrevious && await this.updatePrevious(match, matchLocation, stage, roundNumber);\n        updateNext && await this.updateNext(match, matchLocation, stage, roundNumber, roundCount);\n    }\n    /**\n     * Updates a match based on a partial match.\n     *\n     * @param stored A reference to what will be updated in the storage.\n     * @param match Input of the update.\n     * @param force Whether to force update locked matches.\n     */\n    async updateMatch(stored, match, force) {\n        if (!force && helpers.isMatchUpdateLocked(stored))\n            throw Error('The match is locked.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const inRoundRobin = helpers.isRoundRobin(stage);\n        const { statusChanged, resultChanged } = helpers.setMatchResults(stored, match, inRoundRobin);\n        await this.applyMatchUpdate(stored);\n        // Don't update related matches if it's a simple score update.\n        if (!statusChanged && !resultChanged)\n            return;\n        if (!helpers.isRoundRobin(stage))\n            await this.updateRelatedMatches(stored, statusChanged, resultChanged);\n    }\n    /**\n     * Updates a match game based on a partial match game.\n     *\n     * @param stored A reference to what will be updated in the storage.\n     * @param game Input of the update.\n     */\n    async updateMatchGame(stored, game) {\n        if (helpers.isMatchUpdateLocked(stored))\n            throw Error('The match game is locked.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const inRoundRobin = helpers.isRoundRobin(stage);\n        helpers.setMatchResults(stored, game, inRoundRobin);\n        if (!await this.storage.update('match_game', stored.id, stored))\n            throw Error('Could not update the match game.');\n        await this.updateParentMatch(stored.parent_id, inRoundRobin);\n    }\n    /**\n     * Updates the opponents and status of a match and its child games.\n     *\n     * @param match A match.\n     */\n    async applyMatchUpdate(match) {\n        if (!await this.storage.update('match', match.id, match))\n            throw Error('Could not update the match.');\n        if (match.child_count === 0)\n            return;\n        const updatedMatchGame = {\n            opponent1: helpers.toResult(match.opponent1),\n            opponent2: helpers.toResult(match.opponent2),\n        };\n        // Only sync the child games' status with their parent's status when changing the parent match participants\n        // (Locked, Waiting, Ready) or when archiving the parent match.\n        if (match.status <= brackets_model_1.Status.Ready || match.status === brackets_model_1.Status.Archived)\n            updatedMatchGame.status = match.status;\n        if (!await this.storage.update('match_game', { parent_id: match.id }, updatedMatchGame))\n            throw Error('Could not update the match game.');\n    }\n    /**\n     * Updates the match(es) leading to the current match based on this match results.\n     *\n     * @param match Input of the update.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async updatePrevious(match, matchLocation, stage, roundNumber) {\n        const previousMatches = await this.getPreviousMatches(match, matchLocation, stage, roundNumber);\n        if (previousMatches.length === 0)\n            return;\n        if (match.status >= brackets_model_1.Status.Running)\n            await this.archiveMatches(previousMatches);\n        else\n            await this.resetMatchesStatus(previousMatches);\n    }\n    /**\n     * Sets the status of a list of matches to archived.\n     *\n     * @param matches The matches to update.\n     */\n    async archiveMatches(matches) {\n        for (const match of matches) {\n            match.status = brackets_model_1.Status.Archived;\n            await this.applyMatchUpdate(match);\n        }\n    }\n    /**\n     * Resets the status of a list of matches to what it should currently be.\n     *\n     * @param matches The matches to update.\n     */\n    async resetMatchesStatus(matches) {\n        for (const match of matches) {\n            match.status = helpers.getMatchStatus(match);\n            await this.applyMatchUpdate(match);\n        }\n    }\n    /**\n     * Updates the match(es) following the current match based on this match results.\n     *\n     * @param match Input of the update.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     * @param roundCount Count of rounds.\n     */\n    async updateNext(match, matchLocation, stage, roundNumber, roundCount) {\n        const nextMatches = await this.getNextMatches(match, matchLocation, stage, roundNumber, roundCount);\n        if (nextMatches.length === 0)\n            return;\n        const winnerSide = helpers.getMatchResult(match);\n        const actualRoundNumber = (stage.settings.skipFirstRound && matchLocation === 'winner_bracket') ? roundNumber + 1 : roundNumber;\n        if (winnerSide)\n            await this.applyToNextMatches(helpers.setNextOpponent, match, matchLocation, actualRoundNumber, roundCount, nextMatches, winnerSide);\n        else\n            await this.applyToNextMatches(helpers.resetNextOpponent, match, matchLocation, actualRoundNumber, roundCount, nextMatches);\n    }\n    /**\n     * Applies a SetNextOpponent function to matches following the current match.\n     *\n     * @param setNextOpponent The SetNextOpponent function.\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param roundNumber Number of the current round.\n     * @param roundCount Count of rounds.\n     * @param nextMatches The matches following the current match.\n     * @param winnerSide Side of the winner in the current match.\n     */\n    async applyToNextMatches(setNextOpponent, match, matchLocation, roundNumber, roundCount, nextMatches, winnerSide) {\n        if (matchLocation === 'final_group') {\n            if (!nextMatches[0])\n                throw Error('First next match is null.');\n            setNextOpponent(nextMatches[0], 'opponent1', match, 'opponent1');\n            setNextOpponent(nextMatches[0], 'opponent2', match, 'opponent2');\n            await this.applyMatchUpdate(nextMatches[0]);\n            return;\n        }\n        const nextSide = helpers.getNextSide(match.number, roundNumber, roundCount, matchLocation);\n        if (nextMatches[0]) {\n            setNextOpponent(nextMatches[0], nextSide, match, winnerSide);\n            await this.propagateByeWinners(nextMatches[0]);\n        }\n        if (nextMatches.length !== 2)\n            return;\n        if (!nextMatches[1])\n            throw Error('Second next match is null.');\n        // The second match is either the consolation final (single elimination) or a loser bracket match (double elimination).\n        if (matchLocation === 'single_bracket') {\n            setNextOpponent(nextMatches[1], nextSide, match, winnerSide && helpers.getOtherSide(winnerSide));\n            await this.applyMatchUpdate(nextMatches[1]);\n        }\n        else {\n            const nextSideLB = helpers.getNextSideLoserBracket(match.number, nextMatches[1], roundNumber);\n            setNextOpponent(nextMatches[1], nextSideLB, match, winnerSide && helpers.getOtherSide(winnerSide));\n            await this.propagateByeWinners(nextMatches[1]);\n        }\n    }\n    /**\n     * Propagates winner against BYEs in related matches.\n     *\n     * @param match The current match.\n     */\n    async propagateByeWinners(match) {\n        helpers.setMatchResults(match, match, false); // BYE propagation is only in non round-robin stages.\n        await this.applyMatchUpdate(match);\n        if (helpers.hasBye(match))\n            await this.updateRelatedMatches(match, true, true);\n    }\n}\nexports.BaseUpdater = BaseUpdater;\n//# sourceMappingURL=updater.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/base/updater.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/create.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/create.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Create = exports.create = void 0;\nconst ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\n/**\n * Creates a stage.\n *\n * @param this Instance of BracketsManager.\n * @param stage The stage to create.\n */\nasync function create(stage) {\n    const instance = new Create(this.storage, stage);\n    await instance.run();\n}\nexports.create = create;\nclass Create {\n    /**\n     * Creates an instance of Create, which will handle the creation of the stage.\n     *\n     * @param storage The implementation of Storage.\n     * @param stage The stage to create.\n     */\n    constructor(storage, stage) {\n        this.storage = storage;\n        this.stage = stage;\n        this.stage.settings = this.stage.settings || {};\n        this.seedOrdering = this.stage.settings.seedOrdering || [];\n        this.updateMode = false;\n        this.enableByesInUpdate = false;\n        if (!this.stage.name)\n            throw Error('You must provide a name for the stage.');\n        if (!Number.isInteger(this.stage.tournamentId))\n            throw Error('You must provide a tournament id for the stage.');\n        if (stage.type === 'round_robin')\n            this.stage.settings.roundRobinMode = this.stage.settings.roundRobinMode || 'simple';\n        if (stage.type === 'single_elimination')\n            this.stage.settings.consolationFinal = this.stage.settings.consolationFinal || false;\n        if (stage.type === 'double_elimination')\n            this.stage.settings.grandFinal = this.stage.settings.grandFinal || 'none';\n        this.stage.settings.matchesChildCount = this.stage.settings.matchesChildCount || 0;\n    }\n    /**\n     * Run the creation process.\n     */\n    async run() {\n        let stageId = -1;\n        switch (this.stage.type) {\n            case 'round_robin':\n                stageId = await this.roundRobin();\n                break;\n            case 'single_elimination':\n                stageId = await this.singleElimination();\n                break;\n            case 'double_elimination':\n                stageId = await this.doubleElimination();\n                break;\n            default:\n                throw Error('Unknown stage type.');\n        }\n        if (stageId === -1)\n            throw Error('Something went wrong when creating the stage.');\n        await this.ensureSeedOrdering(stageId);\n    }\n    /**\n     * Enables the update mode.\n     *\n     * @param stageId ID of the stage.\n     * @param enableByes Whether to use BYEs or TBDs for `null` values in an input seeding.\n     */\n    setExisting(stageId, enableByes) {\n        this.updateMode = true;\n        this.currentStageId = stageId;\n        this.enableByesInUpdate = enableByes;\n    }\n    /**\n     * Creates a round-robin stage.\n     *\n     * Group count must be given. It will distribute participants in groups and rounds.\n     */\n    async roundRobin() {\n        const groups = await this.getRoundRobinGroups();\n        const stageId = await this.createStage();\n        for (let i = 0; i < groups.length; i++)\n            await this.createRoundRobinGroup(stageId, i + 1, groups[i]);\n        return stageId;\n    }\n    /**\n     * Creates a single elimination stage.\n     *\n     * One bracket and optionally a consolation final between semi-final losers.\n     */\n    async singleElimination() {\n        var _a, _b;\n        if (Array.isArray((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering) &&\n            ((_b = this.stage.settings) === null || _b === void 0 ? void 0 : _b.seedOrdering.length) !== 1)\n            throw Error('You must specify one seed ordering method.');\n        const slots = await this.getSlots();\n        const stageId = await this.createStage();\n        const method = this.getStandardBracketFirstRoundOrdering();\n        const ordered = ordering_1.ordering[method](slots);\n        const { losers } = await this.createStandardBracket(stageId, 1, ordered);\n        await this.createConsolationFinal(stageId, losers);\n        return stageId;\n    }\n    /**\n     * Creates a double elimination stage.\n     *\n     * One upper bracket (winner bracket, WB), one lower bracket (loser bracket, LB) and optionally a grand final\n     * between the winner of both bracket, which can be simple or double.\n     */\n    async doubleElimination() {\n        var _a;\n        if (this.stage.settings && Array.isArray(this.stage.settings.seedOrdering) &&\n            this.stage.settings.seedOrdering.length < 1)\n            throw Error('You must specify at least one seed ordering method.');\n        const slots = await this.getSlots();\n        const stageId = await this.createStage();\n        const method = this.getStandardBracketFirstRoundOrdering();\n        const ordered = ordering_1.ordering[method](slots);\n        if ((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.skipFirstRound)\n            return this.createDoubleEliminationSkipFirstRound(stageId, ordered);\n        return this.createDoubleElimination(stageId, ordered);\n    }\n    /**\n     * Creates a double elimination stage with skip first round option.\n     *\n     * @param stageId ID of the stage.\n     * @param slots A list of slots.\n     */\n    async createDoubleEliminationSkipFirstRound(stageId, slots) {\n        var _a;\n        const { even: directInWb, odd: directInLb } = helpers.splitByParity(slots);\n        const { losers: losersWb, winner: winnerWb } = await this.createStandardBracket(stageId, 1, directInWb);\n        if (helpers.isDoubleEliminationNecessary((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size)) {\n            const winnerLb = await this.createLowerBracket(stageId, 2, [directInLb, ...losersWb]);\n            await this.createGrandFinal(stageId, winnerWb, winnerLb);\n        }\n        return stageId;\n    }\n    /**\n     * Creates a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     * @param slots A list of slots.\n     */\n    async createDoubleElimination(stageId, slots) {\n        var _a;\n        const { losers: losersWb, winner: winnerWb } = await this.createStandardBracket(stageId, 1, slots);\n        if (helpers.isDoubleEliminationNecessary((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size)) {\n            const winnerLb = await this.createLowerBracket(stageId, 2, losersWb);\n            await this.createGrandFinal(stageId, winnerWb, winnerLb);\n        }\n        return stageId;\n    }\n    /**\n     * Creates a round-robin group.\n     *\n     * This will make as many rounds as needed to let each participant match every other once.\n     *\n     * @param stageId ID of the parent stage.\n     * @param number Number in the stage.\n     * @param slots A list of slots.\n     */\n    async createRoundRobinGroup(stageId, number, slots) {\n        var _a;\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        const rounds = helpers.makeRoundRobinMatches(slots, (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.roundRobinMode);\n        for (let i = 0; i < rounds.length; i++)\n            await this.createRound(stageId, groupId, i + 1, rounds[0].length, rounds[i]);\n    }\n    /**\n     * Creates a standard bracket, which is the only one in single elimination and the upper one in double elimination.\n     *\n     * This will make as many rounds as needed to end with one winner.\n     *\n     * @param stageId ID of the parent stage.\n     * @param number Number in the stage.\n     * @param slots A list of slots.\n     */\n    async createStandardBracket(stageId, number, slots) {\n        const roundCount = helpers.getUpperBracketRoundCount(slots.length);\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        let duels = helpers.makePairs(slots);\n        let roundNumber = 1;\n        const losers = [];\n        for (let i = roundCount - 1; i >= 0; i--) {\n            const matchCount = Math.pow(2, i);\n            duels = this.getCurrentDuels(duels, matchCount);\n            losers.push(duels.map(helpers.byeLoser));\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n        }\n        return { losers, winner: helpers.byeWinner(duels[0]) };\n    }\n    /**\n     * Creates a lower bracket, alternating between major and minor rounds.\n     *\n     * - A major round is a regular round.\n     * - A minor round matches the previous (major) round's winners against upper bracket losers of the corresponding round.\n     *\n     * @param stageId ID of the parent stage.\n     * @param number Number in the stage.\n     * @param losers One list of losers per upper bracket round.\n     */\n    async createLowerBracket(stageId, number, losers) {\n        var _a;\n        const participantCount = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size;\n        const roundPairCount = helpers.getRoundPairCount(participantCount);\n        let losersId = 0;\n        const method = this.getMajorOrdering(participantCount);\n        const ordered = ordering_1.ordering[method](losers[losersId++]);\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        let duels = helpers.makePairs(ordered);\n        let roundNumber = 1;\n        for (let i = 0; i < roundPairCount; i++) {\n            const matchCount = Math.pow(2, roundPairCount - i - 1);\n            // Major round.\n            duels = this.getCurrentDuels(duels, matchCount, true);\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n            // Minor round.\n            const minorOrdering = this.getMinorOrdering(participantCount, i, roundPairCount);\n            duels = this.getCurrentDuels(duels, matchCount, false, losers[losersId++], minorOrdering);\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n        }\n        return helpers.byeWinnerToGrandFinal(duels[0]);\n    }\n    /**\n     * Creates a bracket with rounds that only have 1 match each. Used for finals.\n     *\n     * @param stageId ID of the parent stage.\n     * @param number Number in the stage.\n     * @param duels A list of duels.\n     */\n    async createUniqueMatchBracket(stageId, number, duels) {\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        for (let i = 0; i < duels.length; i++)\n            await this.createRound(stageId, groupId, i + 1, 1, [duels[i]]);\n    }\n    /**\n     * Creates a round, which contain matches.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupId ID of the parent group.\n     * @param roundNumber Number in the group.\n     * @param matchCount Duel/match count.\n     * @param duels A list of duels.\n     */\n    async createRound(stageId, groupId, roundNumber, matchCount, duels) {\n        const matchesChildCount = this.getMatchesChildCount();\n        const roundId = await this.insertRound({\n            number: roundNumber,\n            stage_id: stageId,\n            group_id: groupId,\n        });\n        if (roundId === -1)\n            throw Error('Could not insert the round.');\n        for (let i = 0; i < matchCount; i++)\n            await this.createMatch(stageId, groupId, roundId, i + 1, duels[i], matchesChildCount);\n    }\n    /**\n     * Creates a match, possibly with match games.\n     *\n     * - If `childCount` is 0, then there is no children. The score of the match is directly its intrinsic score.\n     * - If `childCount` is greater than 0, then the score of the match will automatically be calculated based on its child games.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupId ID of the parent group.\n     * @param roundId ID of the parent round.\n     * @param matchNumber Number in the round.\n     * @param opponents The two opponents matching against each other.\n     * @param childCount Child count for this match (number of games).\n     */\n    async createMatch(stageId, groupId, roundId, matchNumber, opponents, childCount) {\n        const opponent1 = helpers.toResultWithPosition(opponents[0]);\n        const opponent2 = helpers.toResultWithPosition(opponents[1]);\n        // Round-robin matches can easily be removed. Prevent BYE vs. BYE matches.\n        if (this.stage.type === 'round_robin' && opponent1 === null && opponent2 === null)\n            return;\n        let existing = null;\n        let status = helpers.getMatchStatus(opponents);\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('match', {\n                round_id: roundId,\n                number: matchNumber,\n            });\n            const currentChildCount = existing === null || existing === void 0 ? void 0 : existing.child_count;\n            childCount = currentChildCount === undefined ? childCount : currentChildCount;\n            if (existing) {\n                // Keep the most advanced status when updating a match.\n                const existingStatus = helpers.getMatchStatus(existing);\n                if (existingStatus > status)\n                    status = existingStatus;\n            }\n        }\n        const parentId = await this.insertMatch({\n            number: matchNumber,\n            stage_id: stageId,\n            group_id: groupId,\n            round_id: roundId,\n            child_count: childCount,\n            status: status,\n            opponent1,\n            opponent2,\n        }, existing);\n        if (parentId === -1)\n            throw Error('Could not insert the match.');\n        for (let i = 0; i < childCount; i++) {\n            const id = await this.insertMatchGame({\n                number: i + 1,\n                stage_id: stageId,\n                parent_id: parentId,\n                status: status,\n                opponent1: helpers.toResult(opponents[0]),\n                opponent2: helpers.toResult(opponents[1]),\n            });\n            if (id === -1)\n                throw Error('Could not insert the match game.');\n        }\n    }\n    /**\n     * Generic implementation.\n     *\n     * @param previousDuels Always given.\n     * @param currentDuelCount Always given.\n     * @param major Only for loser bracket.\n     * @param losers Only for minor rounds of loser bracket.\n     * @param method Only for minor rounds. Ordering method for the losers.\n     */\n    getCurrentDuels(previousDuels, currentDuelCount, major, losers, method) {\n        if ((major === undefined || major) && previousDuels.length === currentDuelCount) {\n            // First round.\n            return previousDuels;\n        }\n        if (major === undefined || major) {\n            // From major to major (WB) or minor to major (LB).\n            return helpers.transitionToMajor(previousDuels);\n        }\n        // From major to minor (LB).\n        // Losers and method won't be undefined.\n        return helpers.transitionToMinor(previousDuels, losers, method);\n    }\n    /**\n     * Returns a list of slots.\n     * - If `seeding` was given, inserts them in the storage.\n     * - If `size` was given, only returns a list of empty slots.\n     *\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlots(positions) {\n        var _a, _b;\n        const size = ((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size) || ((_b = this.stage.seeding) === null || _b === void 0 ? void 0 : _b.length) || 0;\n        helpers.ensureValidSize(size);\n        if (size && !this.stage.seeding)\n            return Array.from(Array(size), (_, i) => ({ id: null, position: i + 1 }));\n        if (!this.stage.seeding)\n            throw Error('Either size or seeding must be given.');\n        this.stage.settings = {\n            ...this.stage.settings,\n            size, // Always set the size.\n        };\n        helpers.ensureNoDuplicates(this.stage.seeding);\n        this.stage.seeding = helpers.fixSeeding(this.stage.seeding, size);\n        if (this.stage.type !== 'round_robin' && this.stage.settings.balanceByes)\n            this.stage.seeding = helpers.balanceByes(this.stage.seeding, this.stage.settings.size);\n        if (helpers.isSeedingWithIds(this.stage.seeding))\n            return this.getSlotsUsingIds(this.stage.seeding, positions);\n        return this.getSlotsUsingNames(this.stage.seeding, positions);\n    }\n    /**\n     * Returns the list of slots with a seeding containing names. Participants may be added to database.\n     *\n     * @param seeding The seeding (names).\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlotsUsingNames(seeding, positions) {\n        const participants = helpers.extractParticipantsFromSeeding(this.stage.tournamentId, seeding);\n        if (!await this.registerParticipants(participants))\n            throw Error('Error registering the participants.');\n        // Get participants back with IDs.\n        const added = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        if (!added)\n            throw Error('Error getting registered participant.');\n        return helpers.mapParticipantsNamesToDatabase(seeding, added, positions);\n    }\n    /**\n     * Returns the list of slots with a seeding containing IDs. No database mutation.\n     *\n     * @param seeding The seeding (IDs).\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlotsUsingIds(seeding, positions) {\n        const participants = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        if (!participants)\n            throw Error('No available participants.');\n        return helpers.mapParticipantsIdsToDatabase(seeding, participants, positions);\n    }\n    /**\n     * Gets the current stage number based on existing stages.\n     */\n    async getStageNumber() {\n        const stages = await this.storage.select('stage', { tournament_id: this.stage.tournamentId });\n        const stageNumbers = stages === null || stages === void 0 ? void 0 : stages.map(stage => stage.number);\n        if (this.stage.number !== undefined) {\n            if (stageNumbers === null || stageNumbers === void 0 ? void 0 : stageNumbers.includes(this.stage.number))\n                throw Error('The given stage number already exists.');\n            return this.stage.number;\n        }\n        if (!(stageNumbers === null || stageNumbers === void 0 ? void 0 : stageNumbers.length))\n            return 1;\n        const maxNumber = Math.max(...stageNumbers);\n        return maxNumber + 1;\n    }\n    /**\n     * Safely gets `matchesChildCount` in the stage input settings.\n     */\n    getMatchesChildCount() {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.matchesChildCount))\n            return 0;\n        return this.stage.settings.matchesChildCount;\n    }\n    /**\n     * Safely gets an ordering by its index in the stage input settings.\n     *\n     * @param orderingIndex Index of the ordering.\n     * @param stageType A value indicating if the method should be a group method or not.\n     * @param defaultMethod The default method to use if not given.\n     */\n    getOrdering(orderingIndex, stageType, defaultMethod) {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering)) {\n            this.seedOrdering.push(defaultMethod);\n            return defaultMethod;\n        }\n        const method = this.stage.settings.seedOrdering[orderingIndex];\n        if (!method) {\n            this.seedOrdering.push(defaultMethod);\n            return defaultMethod;\n        }\n        if (stageType === 'elimination' && method.match(/^groups\\./))\n            throw Error('You must specify a seed ordering method without a \\'groups\\' prefix');\n        if (stageType === 'groups' && method !== 'natural' && !method.match(/^groups\\./))\n            throw Error('You must specify a seed ordering method with a \\'groups\\' prefix');\n        return method;\n    }\n    /**\n     * Gets the duels in groups for a round-robin stage.\n     */\n    async getRoundRobinGroups() {\n        var _a, _b, _c, _d, _e;\n        if (((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.groupCount) === undefined || !Number.isInteger(this.stage.settings.groupCount))\n            throw Error('You must specify a group count for round-robin stages.');\n        if (this.stage.settings.groupCount <= 0)\n            throw Error('You must provide a strictly positive group count.');\n        if ((_b = this.stage.settings) === null || _b === void 0 ? void 0 : _b.manualOrdering) {\n            if (((_c = this.stage.settings) === null || _c === void 0 ? void 0 : _c.manualOrdering.length) !== ((_d = this.stage.settings) === null || _d === void 0 ? void 0 : _d.groupCount))\n                throw Error('Group count in the manual ordering does not correspond to the given group count.');\n            const positions = (_e = this.stage.settings) === null || _e === void 0 ? void 0 : _e.manualOrdering.flat();\n            const slots = await this.getSlots(positions);\n            return helpers.makeGroups(slots, this.stage.settings.groupCount);\n        }\n        if (Array.isArray(this.stage.settings.seedOrdering) && this.stage.settings.seedOrdering.length !== 1)\n            throw Error('You must specify one seed ordering method.');\n        const method = this.getRoundRobinOrdering();\n        const slots = await this.getSlots();\n        const ordered = ordering_1.ordering[method](slots, this.stage.settings.groupCount);\n        return helpers.makeGroups(ordered, this.stage.settings.groupCount);\n    }\n    /**\n     * Returns the ordering method for the groups in a round-robin stage.\n     */\n    getRoundRobinOrdering() {\n        return this.getOrdering(0, 'groups', 'groups.effort_balanced');\n    }\n    /**\n     * Returns the ordering method for the first round of the upper bracket of an elimination stage.\n     */\n    getStandardBracketFirstRoundOrdering() {\n        return this.getOrdering(0, 'elimination', 'inner_outer');\n    }\n    /**\n     * Safely gets the only major ordering for the lower bracket.\n     *\n     * @param participantCount Number of participants in the stage.\n     */\n    getMajorOrdering(participantCount) {\n        var _a;\n        return this.getOrdering(1, 'elimination', ((_a = ordering_1.defaultMinorOrdering[participantCount]) === null || _a === void 0 ? void 0 : _a[0]) || 'natural');\n    }\n    /**\n     * Safely gets a minor ordering for the lower bracket by its index.\n     *\n     * @param participantCount Number of participants in the stage.\n     * @param index Index of the minor round.\n     * @param minorRoundCount Number of minor rounds.\n     */\n    getMinorOrdering(participantCount, index, minorRoundCount) {\n        var _a;\n        // No ordering for the last minor round. There is only one participant to order.\n        if (index === minorRoundCount - 1)\n            return undefined;\n        return this.getOrdering(2 + index, 'elimination', ((_a = ordering_1.defaultMinorOrdering[participantCount]) === null || _a === void 0 ? void 0 : _a[1 + index]) || 'natural');\n    }\n    /**\n     * Inserts a stage or finds an existing one.\n     *\n     * @param stage The stage to insert.\n     */\n    async insertStage(stage) {\n        let existing = null;\n        if (this.updateMode)\n            existing = await this.storage.select('stage', this.currentStageId);\n        if (!existing)\n            return this.storage.insert('stage', stage);\n        return existing.id;\n    }\n    /**\n     * Inserts a group or finds an existing one.\n     *\n     * @param group The group to insert.\n     */\n    async insertGroup(group) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('group', {\n                stage_id: group.stage_id,\n                number: group.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('group', group);\n        return existing.id;\n    }\n    /**\n     * Inserts a round or finds an existing one.\n     *\n     * @param round The round to insert.\n     */\n    async insertRound(round) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('round', {\n                group_id: round.group_id,\n                number: round.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('round', round);\n        return existing.id;\n    }\n    /**\n     * Inserts a match or updates an existing one.\n     *\n     * @param match The match to insert.\n     * @param existing An existing match corresponding to the current one.\n     */\n    async insertMatch(match, existing) {\n        if (!existing)\n            return this.storage.insert('match', match);\n        const updated = helpers.getUpdatedMatchResults(match, existing, this.enableByesInUpdate);\n        if (!await this.storage.update('match', existing.id, updated))\n            throw Error('Could not update the match.');\n        return existing.id;\n    }\n    /**\n     * Inserts a match game or finds an existing one (and updates it).\n     *\n     * @param matchGame The match game to insert.\n     */\n    async insertMatchGame(matchGame) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('match_game', {\n                parent_id: matchGame.parent_id,\n                number: matchGame.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('match_game', matchGame);\n        const updated = helpers.getUpdatedMatchResults(matchGame, existing, this.enableByesInUpdate);\n        if (!await this.storage.update('match_game', existing.id, updated))\n            throw Error('Could not update the match game.');\n        return existing.id;\n    }\n    /**\n     * Inserts missing participants.\n     *\n     * @param participants The list of participants to process.\n     */\n    async registerParticipants(participants) {\n        const existing = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        // Insert all if nothing.\n        if (!existing || existing.length === 0)\n            return this.storage.insert('participant', participants);\n        // Insert only missing otherwise.\n        for (const participant of participants) {\n            if (existing.some(value => value.name === participant.name))\n                continue;\n            const result = await this.storage.insert('participant', participant);\n            if (result === -1)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Creates a new stage.\n     */\n    async createStage() {\n        const stageNumber = await this.getStageNumber();\n        const stageId = await this.insertStage({\n            tournament_id: this.stage.tournamentId,\n            name: this.stage.name,\n            type: this.stage.type,\n            number: stageNumber,\n            settings: this.stage.settings || {},\n        });\n        if (stageId === -1)\n            throw Error('Could not insert the stage.');\n        return stageId;\n    }\n    /**\n     * Creates a consolation final for the semi final losers of a single elimination stage.\n     *\n     * @param stageId ID of the stage.\n     * @param losers The semi final losers who will play the consolation final.\n     */\n    async createConsolationFinal(stageId, losers) {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.consolationFinal))\n            return;\n        const semiFinalLosers = losers[losers.length - 2];\n        await this.createUniqueMatchBracket(stageId, 2, [semiFinalLosers]);\n    }\n    /**\n     * Creates a grand final (none, simple or double) for winners of both bracket in a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     * @param winnerWb The winner of the winner bracket.\n     * @param winnerLb The winner of the loser bracket.\n     */\n    async createGrandFinal(stageId, winnerWb, winnerLb) {\n        var _a;\n        // No Grand Final by default.\n        const grandFinal = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.grandFinal;\n        if (grandFinal === 'none')\n            return;\n        // One duel by default.\n        const finalDuels = [[winnerWb, winnerLb]];\n        // Second duel.\n        if (grandFinal === 'double')\n            finalDuels.push([{ id: null }, { id: null }]);\n        await this.createUniqueMatchBracket(stageId, 3, finalDuels);\n    }\n    /**\n     * Ensures that the seed ordering list is stored even if it was not given in the first place.\n     *\n     * @param stageId ID of the stage.\n     */\n    async ensureSeedOrdering(stageId) {\n        var _a, _b;\n        if (((_b = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering) === null || _b === void 0 ? void 0 : _b.length) === this.seedOrdering.length)\n            return;\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        stage.settings = {\n            ...stage.settings,\n            seedOrdering: this.seedOrdering,\n        };\n        if (!await this.storage.update('stage', stageId, stage))\n            throw Error('Could not update the stage.');\n    }\n}\nexports.Create = Create;\n//# sourceMappingURL=create.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/create.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/delete.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/delete.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Delete = void 0;\nclass Delete {\n    /**\n     * Creates an instance of Delete, which will handle cleanly deleting data in the storage.\n     *\n     * @param storage The implementation of Storage.\n     */\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /**\n     * Deletes a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async stage(stageId) {\n        // The order is important because the abstract storage possibly has foreign checks.\n        if (!await this.storage.delete('match_game', { stage_id: stageId }))\n            throw Error('Could not delete match games.');\n        if (!await this.storage.delete('match', { stage_id: stageId }))\n            throw Error('Could not delete matches.');\n        if (!await this.storage.delete('round', { stage_id: stageId }))\n            throw Error('Could not delete rounds.');\n        if (!await this.storage.delete('group', { stage_id: stageId }))\n            throw Error('Could not delete groups.');\n        if (!await this.storage.delete('stage', { id: stageId }))\n            throw Error('Could not delete stages.');\n    }\n}\nexports.Delete = Delete;\n//# sourceMappingURL=delete.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/delete.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/find.js":
/*!****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/find.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Find = void 0;\nconst getter_1 = __webpack_require__(/*! ./base/getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Find extends getter_1.BaseGetter {\n    /**\n     * Gets the upper bracket (the only bracket if single elimination or the winner bracket in double elimination).\n     *\n     * @param stageId ID of the stage.\n     */\n    async upperBracket(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('Round-robin stages do not have an upper bracket.');\n            case 'single_elimination':\n            case 'double_elimination':\n                return this.getUpperBracket(stageId);\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Gets the loser bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async loserBracket(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('Round-robin stages do not have a loser bracket.');\n            case 'single_elimination':\n                throw Error('Single elimination stages do not have a loser bracket.');\n            case 'double_elimination':\n                const group = await this.getLoserBracket(stageId);\n                if (!group)\n                    throw Error('Loser bracket not found.');\n                return group;\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Returns the matches leading to the given match.\n     *\n     * @param matchId ID of the target match.\n     */\n    async previousMatches(matchId) {\n        const match = await this.storage.select('match', matchId);\n        if (!match)\n            throw Error('Match not found.');\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const round = await this.storage.select('round', match.round_id);\n        if (!round)\n            throw Error('Round not found.');\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        return this.getPreviousMatches(match, matchLocation, stage, round.number);\n    }\n    /**\n     * Returns the matches following the given match.\n     *\n     * @param matchId ID of the target match.\n     */\n    async nextMatches(matchId) {\n        const match = await this.storage.select('match', matchId);\n        if (!match)\n            throw Error('Match not found.');\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(match.round_id);\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        const nextMatches = await this.getNextMatches(match, matchLocation, stage, roundNumber, roundCount);\n        return helpers.getNonNull(nextMatches);\n    }\n    /**\n     * Finds a match in a given group. The match must have the given number in a round of which the number in group is given.\n     *\n     * **Example:** In group of id 1, give me the 4th match in the 3rd round.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async match(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber, matchNumber);\n    }\n    /**\n     * Finds a match game based on its `id` or based on the combination of its `parent_id` and `number`.\n     *\n     * @param game Values to change in a match game.\n     */\n    async matchGame(game) {\n        return this.findMatchGame(game);\n    }\n}\nexports.Find = Find;\n//# sourceMappingURL=find.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/find.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/get.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-manager/dist/get.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Get = void 0;\nconst getter_1 = __webpack_require__(/*! ./base/getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Get extends getter_1.BaseGetter {\n    /**\n     * Returns the data needed to display a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async stageData(stageId) {\n        const stageData = await this.getStageSpecificData(stageId);\n        const participants = await this.storage.select('participant', { tournament_id: stageData.stage.tournament_id });\n        if (!participants)\n            throw Error('Error getting participants.');\n        return {\n            stage: [stageData.stage],\n            group: stageData.groups,\n            round: stageData.rounds,\n            match: stageData.matches,\n            match_game: stageData.matchGames,\n            participant: participants,\n        };\n    }\n    /**\n     * Returns the data needed to display a whole tournament with all its stages.\n     *\n     * @param tournamentId ID of the tournament.\n     */\n    async tournamentData(tournamentId) {\n        const stages = await this.storage.select('stage', { tournament_id: tournamentId });\n        if (!stages)\n            throw Error('Error getting stages.');\n        const stagesData = await Promise.all(stages.map(stage => this.getStageSpecificData(stage.id)));\n        const participants = await this.storage.select('participant', { tournament_id: tournamentId });\n        if (!participants)\n            throw Error('Error getting participants.');\n        return {\n            stage: stages,\n            group: stagesData.reduce((acc, data) => [...acc, ...data.groups], []),\n            round: stagesData.reduce((acc, data) => [...acc, ...data.rounds], []),\n            match: stagesData.reduce((acc, data) => [...acc, ...data.matches], []),\n            match_game: stagesData.reduce((acc, data) => [...acc, ...data.matchGames], []),\n            participant: participants,\n        };\n    }\n    /**\n     * Returns the match games associated to a list of matches.\n     *\n     * @param matches A list of matches.\n     */\n    async matchGames(matches) {\n        const parentMatches = matches.filter(match => match.child_count > 0);\n        const matchGamesQueries = await Promise.all(parentMatches.map(match => this.storage.select('match_game', { parent_id: match.id })));\n        if (matchGamesQueries.some(game => game === null))\n            throw Error('Error getting match games.');\n        return helpers.getNonNull(matchGamesQueries).flat();\n    }\n    /**\n     * Returns the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async seeding(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        if (stage.type === 'round_robin')\n            return this.roundRobinSeeding(stage);\n        return this.eliminationSeeding(stage);\n    }\n    /**\n     * Returns the final standings of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async finalStandings(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('A round-robin stage does not have standings.');\n            case 'single_elimination':\n                return this.singleEliminationStandings(stageId);\n            case 'double_elimination':\n                return this.doubleEliminationStandings(stageId);\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Returns the seeding of a round-robin stage.\n     *\n     * @param stage The stage.\n     */\n    async roundRobinSeeding(stage) {\n        if (stage.settings.size === undefined)\n            throw Error('The size of the seeding is undefined.');\n        const matches = await this.storage.select('match', { stage_id: stage.id });\n        if (!matches)\n            throw Error('Error getting matches.');\n        const slots = helpers.convertMatchesToSeeding(matches);\n        // BYE vs. BYE matches of a round-robin stage are removed\n        // when the stage is created. We need to add them back temporarily.\n        if (slots.length < stage.settings.size) {\n            const diff = stage.settings.size - slots.length;\n            for (let i = 0; i < diff; i++)\n                slots.push(null);\n        }\n        const unique = helpers.uniqueBy(slots, item => item && item.position);\n        const seeding = helpers.setArraySize(unique, stage.settings.size, null);\n        return seeding;\n    }\n    /**\n     * Returns the seeding of an elimination stage.\n     *\n     * @param stage The stage.\n     */\n    async eliminationSeeding(stage) {\n        const round = await this.storage.selectFirst('round', { stage_id: stage.id, number: 1 });\n        if (!round)\n            throw Error('Error getting the first round.');\n        const matches = await this.storage.select('match', { round_id: round.id });\n        if (!matches)\n            throw Error('Error getting matches.');\n        return helpers.convertMatchesToSeeding(matches);\n    }\n    /**\n     * Returns the final standings of a single elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async singleEliminationStandings(stageId) {\n        var _a;\n        const grouped = [];\n        const { stage: stages, group: groups, match: matches, participant: participants } = await this.stageData(stageId);\n        const [stage] = stages;\n        const [singleBracket, finalGroup] = groups;\n        const final = matches.filter(match => match.group_id === singleBracket.id).pop();\n        if (!final)\n            throw Error('Final not found.');\n        // 1st place: Final winner.\n        grouped[0] = [helpers.findParticipant(participants, helpers.getWinner(final))];\n        // Rest: every loser in reverse order.\n        const losers = helpers.getLosers(participants, matches.filter(match => match.group_id === singleBracket.id));\n        grouped.push(...losers.reverse());\n        if ((_a = stage.settings) === null || _a === void 0 ? void 0 : _a.consolationFinal) {\n            const consolationFinal = matches.filter(match => match.group_id === finalGroup.id).pop();\n            if (!consolationFinal)\n                throw Error('Consolation final not found.');\n            // Overwrite semi-final losers with the consolation final results.\n            grouped[2][0] = helpers.findParticipant(participants, helpers.getWinner(consolationFinal));\n            grouped[2][1] = helpers.findParticipant(participants, helpers.getLoser(consolationFinal));\n        }\n        return helpers.makeFinalStandings(grouped);\n    }\n    /**\n     * Returns the final standings of a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async doubleEliminationStandings(stageId) {\n        var _a, _b;\n        const grouped = [];\n        const { stage: stages, group: groups, match: matches, participant: participants } = await this.stageData(stageId);\n        const [stage] = stages;\n        const [winnerBracket, loserBracket, finalGroup] = groups;\n        if (((_a = stage.settings) === null || _a === void 0 ? void 0 : _a.grandFinal) === 'none') {\n            const finalWB = matches.filter(match => match.group_id === winnerBracket.id).pop();\n            if (!finalWB)\n                throw Error('WB final not found.');\n            const finalLB = matches.filter(match => match.group_id === loserBracket.id).pop();\n            if (!finalLB)\n                throw Error('LB final not found.');\n            // 1st place: WB Final winner.\n            grouped[0] = [helpers.findParticipant(participants, helpers.getWinner(finalWB))];\n            // 2nd place: LB Final winner.\n            grouped[1] = [helpers.findParticipant(participants, helpers.getWinner(finalLB))];\n        }\n        else {\n            const grandFinalMatches = matches.filter(match => match.group_id === finalGroup.id);\n            const decisiveMatch = helpers.getGrandFinalDecisiveMatch(((_b = stage.settings) === null || _b === void 0 ? void 0 : _b.grandFinal) || 'none', grandFinalMatches);\n            // 1st place: Grand Final winner.\n            grouped[0] = [helpers.findParticipant(participants, helpers.getWinner(decisiveMatch))];\n            // 2nd place: Grand Final loser.\n            grouped[1] = [helpers.findParticipant(participants, helpers.getLoser(decisiveMatch))];\n        }\n        // Rest: every loser in reverse order.\n        const losers = helpers.getLosers(participants, matches.filter(match => match.group_id === loserBracket.id));\n        grouped.push(...losers.reverse());\n        return helpers.makeFinalStandings(grouped);\n    }\n    /**\n     * Returns only the data specific to the given stage (without the participants).\n     *\n     * @param stageId ID of the stage.\n     */\n    async getStageSpecificData(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        const groups = await this.storage.select('group', { stage_id: stageId });\n        if (!groups)\n            throw Error('Error getting groups.');\n        const rounds = await this.storage.select('round', { stage_id: stageId });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const matches = await this.storage.select('match', { stage_id: stageId });\n        if (!matches)\n            throw Error('Error getting matches.');\n        const matchGames = await this.matchGames(matches);\n        return {\n            stage,\n            groups,\n            rounds,\n            matches,\n            matchGames,\n        };\n    }\n}\nexports.Get = Get;\n//# sourceMappingURL=get.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/get.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/helpers.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNextSideLoserBracket = exports.getNextSide = exports.findParticipant = exports.getGrandFinalDecisiveMatch = exports.makeFinalStandings = exports.getLosers = exports.getOriginPosition = exports.getOpponentId = exports.resetMatchResults = exports.setMatchResults = exports.getMatchStatus = exports.hasBye = exports.isMatchParticipantLocked = exports.isMatchUpdateLocked = exports.isMatchByeCompleted = exports.isMatchWinCompleted = exports.isMatchDrawCompleted = exports.isMatchResultCompleted = exports.isMatchForfeitCompleted = exports.isMatchCompleted = exports.isMatchStarted = exports.getOtherSide = exports.getSide = exports.findPosition = exports.getMatchResult = exports.byeLoser = exports.byeWinnerToGrandFinal = exports.byeWinner = exports.getLoser = exports.getWinner = exports.toResultWithPosition = exports.toResult = exports.convertTBDtoBYE = exports.ensureNotTied = exports.ensureValidSize = exports.fixSeeding = exports.ensureEquallySized = exports.ensureNoDuplicates = exports.ensureEvenSized = exports.makePairs = exports.setArraySize = exports.normalizeParticipant = exports.makeNormalizedIdMapping = exports.normalizeIds = exports.balanceByes = exports.makeGroups = exports.assertRoundRobin = exports.makeRoundRobinDistribution = exports.makeRoundRobinMatches = exports.splitByParity = void 0;\nexports.getMatchLocation = exports.isFinalGroup = exports.isLoserBracket = exports.isWinnerBracket = exports.ensureNotRoundRobin = exports.isRoundRobin = exports.minScoreToWinBestOfX = exports.getNearestPowerOfTwo = exports.getDiagonalMatchNumber = exports.getLowerBracketRoundCount = exports.getLoserOrdering = exports.getLoserRoundLoserCount = exports.getLoserRoundMatchCount = exports.findLoserMatchNumber = exports.isDoubleEliminationNecessary = exports.getRoundPairCount = exports.getUpperBracketRoundCount = exports.isOrderingSupportedLoserBracket = exports.isOrderingSupportedUpperBracket = exports.ensureOrderingSupported = exports.getSeedCount = exports.getSeeds = exports.getChildGamesResults = exports.getUpdatedMatchResults = exports.getParentMatchResults = exports.setParentMatchCompleted = exports.transitionToMinor = exports.transitionToMajor = exports.uniqueBy = exports.getNonNull = exports.sortSeeding = exports.convertSlotsToSeeding = exports.convertMatchesToSeeding = exports.mapParticipantsToDatabase = exports.mapParticipantsIdsToDatabase = exports.mapParticipantsNamesToDatabase = exports.extractParticipantsFromSeeding = exports.isSeedingWithIds = exports.setForfeits = exports.setResults = exports.setCompleted = exports.setScores = exports.invertOpponents = exports.handleOpponentsInversion = exports.resetNextOpponent = exports.setNextOpponent = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\n/**\n * Splits an array in two parts: one with even indices and the other with odd indices.\n *\n * @param array The array to split.\n */\nfunction splitByParity(array) {\n    return {\n        even: array.filter((_, i) => i % 2 === 0),\n        odd: array.filter((_, i) => i % 2 === 1),\n    };\n}\nexports.splitByParity = splitByParity;\n/**\n * Makes a list of rounds containing the matches of a round-robin group.\n *\n * @param participants The participants to distribute.\n * @param mode The round-robin mode.\n */\nfunction makeRoundRobinMatches(participants, mode = 'simple') {\n    const distribution = makeRoundRobinDistribution(participants);\n    if (mode === 'simple')\n        return distribution;\n    // Reverse rounds and their content.\n    const symmetry = distribution.map(round => [...round].reverse()).reverse();\n    return [...distribution, ...symmetry];\n}\nexports.makeRoundRobinMatches = makeRoundRobinMatches;\n/**\n * Distributes participants in rounds for a round-robin group.\n *\n * Conditions:\n * - Each participant plays each other once.\n * - Each participant plays once in each round.\n *\n * @param participants The participants to distribute.\n */\nfunction makeRoundRobinDistribution(participants) {\n    const n = participants.length;\n    const n1 = n % 2 === 0 ? n : n + 1;\n    const roundCount = n1 - 1;\n    const matchPerRound = n1 / 2;\n    const rounds = [];\n    for (let roundId = 0; roundId < roundCount; roundId++) {\n        const matches = [];\n        for (let matchId = 0; matchId < matchPerRound; matchId++) {\n            if (matchId === 0 && n % 2 === 1)\n                continue;\n            const opponentsIds = [\n                (roundId - matchId - 1 + n1) % (n1 - 1),\n                matchId === 0 ? n1 - 1 : (roundId + matchId) % (n1 - 1),\n            ];\n            matches.push([\n                participants[opponentsIds[0]],\n                participants[opponentsIds[1]],\n            ]);\n        }\n        rounds.push(matches);\n    }\n    return rounds;\n}\nexports.makeRoundRobinDistribution = makeRoundRobinDistribution;\n/**\n * A helper to assert our generated round-robin is correct.\n *\n * @param input The input seeding.\n * @param output The resulting distribution of seeds in groups.\n */\nfunction assertRoundRobin(input, output) {\n    const n = input.length;\n    const matchPerRound = Math.floor(n / 2);\n    const roundCount = n % 2 === 0 ? n - 1 : n;\n    if (output.length !== roundCount)\n        throw Error('Round count is wrong');\n    if (!output.every(round => round.length === matchPerRound))\n        throw Error('Not every round has the good number of matches');\n    const checkAllOpponents = Object.fromEntries(input.map(element => [element, new Set()]));\n    for (const round of output) {\n        const checkUnique = new Set();\n        for (const match of round) {\n            if (match.length !== 2)\n                throw Error('One match is not a pair');\n            if (checkUnique.has(match[0]))\n                throw Error('This team is already playing');\n            checkUnique.add(match[0]);\n            if (checkUnique.has(match[1]))\n                throw Error('This team is already playing');\n            checkUnique.add(match[1]);\n            if (checkAllOpponents[match[0]].has(match[1]))\n                throw Error('The team has already matched this team');\n            checkAllOpponents[match[0]].add(match[1]);\n            if (checkAllOpponents[match[1]].has(match[0]))\n                throw Error('The team has already matched this team');\n            checkAllOpponents[match[1]].add(match[0]);\n        }\n    }\n}\nexports.assertRoundRobin = assertRoundRobin;\n/**\n * Distributes elements in groups of equal size.\n *\n * @param elements A list of elements to distribute in groups.\n * @param groupCount The group count.\n */\nfunction makeGroups(elements, groupCount) {\n    const groupSize = Math.ceil(elements.length / groupCount);\n    const result = [];\n    for (let i = 0; i < elements.length; i++) {\n        if (i % groupSize === 0)\n            result.push([]);\n        result[result.length - 1].push(elements[i]);\n    }\n    return result;\n}\nexports.makeGroups = makeGroups;\n/**\n * Balances BYEs to prevents having BYE against BYE in matches.\n *\n * @param seeding The seeding of the stage.\n * @param participantCount The number of participants in the stage.\n */\nfunction balanceByes(seeding, participantCount) {\n    seeding = seeding.filter(v => v !== null);\n    participantCount = participantCount || getNearestPowerOfTwo(seeding.length);\n    if (seeding.length < participantCount / 2) {\n        const flat = seeding.flatMap(v => [v, null]);\n        return setArraySize(flat, participantCount, null);\n    }\n    const nonNullCount = seeding.length;\n    const nullCount = participantCount - nonNullCount;\n    const againstEachOther = seeding.slice(0, nonNullCount - nullCount).filter((_, i) => i % 2 === 0).map((_, i) => [seeding[2 * i], seeding[2 * i + 1]]);\n    const againstNull = seeding.slice(nonNullCount - nullCount, nonNullCount).map(v => [v, null]);\n    const flat = [...againstEachOther.flat(), ...againstNull.flat()];\n    return setArraySize(flat, participantCount, null);\n}\nexports.balanceByes = balanceByes;\n/**\n * Normalizes IDs in a database.\n *\n * All IDs (and references to them) are remapped to consecutive IDs starting from 0.\n *\n * @param data Data to normalize.\n */\nfunction normalizeIds(data) {\n    const mappings = {\n        participant: makeNormalizedIdMapping(data.participant),\n        stage: makeNormalizedIdMapping(data.stage),\n        group: makeNormalizedIdMapping(data.group),\n        round: makeNormalizedIdMapping(data.round),\n        match: makeNormalizedIdMapping(data.match),\n        match_game: makeNormalizedIdMapping(data.match_game),\n    };\n    return {\n        participant: data.participant.map(value => ({\n            ...value,\n            id: mappings.participant[value.id],\n        })),\n        stage: data.stage.map(value => ({\n            ...value,\n            id: mappings.stage[value.id],\n        })),\n        group: data.group.map(value => ({\n            ...value,\n            id: mappings.group[value.id],\n            stage_id: mappings.stage[value.stage_id],\n        })),\n        round: data.round.map(value => ({\n            ...value,\n            id: mappings.round[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            group_id: mappings.group[value.group_id],\n        })),\n        match: data.match.map(value => ({\n            ...value,\n            id: mappings.match[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            group_id: mappings.group[value.group_id],\n            round_id: mappings.round[value.round_id],\n            opponent1: normalizeParticipant(value.opponent1, mappings.participant),\n            opponent2: normalizeParticipant(value.opponent2, mappings.participant),\n        })),\n        match_game: data.match_game.map(value => ({\n            ...value,\n            id: mappings.match_game[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            parent_id: mappings.match[value.parent_id],\n            opponent1: normalizeParticipant(value.opponent1, mappings.participant),\n            opponent2: normalizeParticipant(value.opponent2, mappings.participant),\n        })),\n    };\n}\nexports.normalizeIds = normalizeIds;\n/**\n * Makes a mapping between old IDs and new normalized IDs.\n *\n * @param elements A list of elements with IDs.\n */\nfunction makeNormalizedIdMapping(elements) {\n    let currentId = 0;\n    return elements.reduce((acc, current) => ({\n        ...acc,\n        [current.id]: currentId++,\n    }), {});\n}\nexports.makeNormalizedIdMapping = makeNormalizedIdMapping;\n/**\n * Apply a normalizing mapping to a participant.\n *\n * @param participant The participant.\n * @param mapping The mapping of IDs.\n */\nfunction normalizeParticipant(participant, mapping) {\n    if (participant === null)\n        return null;\n    return {\n        ...participant,\n        id: participant.id !== null ? mapping[participant.id] : null,\n    };\n}\nexports.normalizeParticipant = normalizeParticipant;\n/**\n * Sets the size of an array with a placeholder if the size is bigger.\n *\n * @param array The original array.\n * @param length The new length.\n * @param placeholder A placeholder to use to fill the empty space.\n */\nfunction setArraySize(array, length, placeholder) {\n    return Array.from(Array(length), (_, i) => array[i] || placeholder);\n}\nexports.setArraySize = setArraySize;\n/**\n * Makes pairs with each element and its next one.\n *\n * @example [1, 2, 3, 4] --> [[1, 2], [3, 4]]\n * @param array A list of elements.\n */\nfunction makePairs(array) {\n    return array.map((_, i) => (i % 2 === 0) ? [array[i], array[i + 1]] : []).filter((v) => v.length === 2);\n}\nexports.makePairs = makePairs;\n/**\n * Ensures that a list of elements has an even size.\n *\n * @param array A list of elements.\n */\nfunction ensureEvenSized(array) {\n    if (array.length % 2 === 1)\n        throw Error('Array size must be even.');\n}\nexports.ensureEvenSized = ensureEvenSized;\n/**\n * Ensures there are no duplicates in a list of elements.\n *\n * @param array A list of elements.\n */\nfunction ensureNoDuplicates(array) {\n    const nonNull = getNonNull(array);\n    const unique = [...new Set(nonNull)];\n    if (unique.length < nonNull.length)\n        throw new Error('The seeding has a duplicate participant.');\n}\nexports.ensureNoDuplicates = ensureNoDuplicates;\n/**\n * Ensures that two lists of elements have the same size.\n *\n * @param left The first list of elements.\n * @param right The second list of elements.\n */\nfunction ensureEquallySized(left, right) {\n    if (left.length !== right.length)\n        throw Error('Arrays\\' size must be equal.');\n}\nexports.ensureEquallySized = ensureEquallySized;\n/**\n * Fixes the seeding by enlarging it if it's not complete.\n *\n * @param seeding The seeding of the stage.\n * @param participantCount The number of participants in the stage.\n */\nfunction fixSeeding(seeding, participantCount) {\n    if (seeding.length > participantCount)\n        throw Error('The seeding has more participants than the size of the stage.');\n    if (seeding.length < participantCount)\n        return setArraySize(seeding, participantCount, null);\n    return seeding;\n}\nexports.fixSeeding = fixSeeding;\n/**\n * Ensures that the participant count is valid.\n *\n * @param participantCount The number to test.\n */\nfunction ensureValidSize(participantCount) {\n    if (participantCount === 0)\n        throw Error('Impossible to create an empty stage. If you want an empty seeding, just set the size of the stage.');\n    if (participantCount < 2)\n        throw Error('Impossible to create a stage with less than 2 participants.');\n    if (!Number.isInteger(Math.log2(participantCount)))\n        throw Error('The library only supports a participant count which is a power of two.');\n}\nexports.ensureValidSize = ensureValidSize;\n/**\n * Ensures that a match scores aren't tied.\n *\n * @param scores Two numbers which are scores.\n */\nfunction ensureNotTied(scores) {\n    if (scores[0] === scores[1])\n        throw Error(`${scores[0]} and ${scores[1]} are tied. It cannot be.`);\n}\nexports.ensureNotTied = ensureNotTied;\n/**\n * Converts a TBD to a BYE.\n *\n * @param slot The slot to convert.\n */\nfunction convertTBDtoBYE(slot) {\n    if (slot === null)\n        return null; // Already a BYE.\n    if ((slot === null || slot === void 0 ? void 0 : slot.id) === null)\n        return null; // Is a TBD.\n    return slot; // Is a determined participant.\n}\nexports.convertTBDtoBYE = convertTBDtoBYE;\n/**\n * Converts a participant slot to a result stored in storage.\n *\n * @param slot A participant slot.\n */\nfunction toResult(slot) {\n    return slot && {\n        id: slot.id,\n    };\n}\nexports.toResult = toResult;\n/**\n * Converts a participant slot to a result stored in storage, with the position the participant is coming from.\n *\n * @param slot A participant slot.\n */\nfunction toResultWithPosition(slot) {\n    return slot && {\n        id: slot.id,\n        position: slot.position,\n    };\n}\nexports.toResultWithPosition = toResultWithPosition;\n/**\n * Returns the winner of a match.\n *\n * @param match The match.\n */\nfunction getWinner(match) {\n    const winnerSide = getMatchResult(match);\n    if (!winnerSide)\n        return null;\n    return match[winnerSide];\n}\nexports.getWinner = getWinner;\n/**\n * Returns the loser of a match.\n *\n * @param match The match.\n */\nfunction getLoser(match) {\n    const winnerSide = getMatchResult(match);\n    if (!winnerSide)\n        return null;\n    return match[getOtherSide(winnerSide)];\n}\nexports.getLoser = getLoser;\n/**\n * Returns the pre-computed winner for a match because of BYEs.\n *\n * @param opponents Two opponents.\n */\nfunction byeWinner(opponents) {\n    if (opponents[0] === null && opponents[1] === null) // Double BYE.\n        return null; // BYE.\n    if (opponents[0] === null && opponents[1] !== null) // opponent1 BYE.\n        return { id: opponents[1].id }; // opponent2.\n    if (opponents[0] !== null && opponents[1] === null) // opponent2 BYE.\n        return { id: opponents[0].id }; // opponent1.\n    return { id: null }; // Normal.\n}\nexports.byeWinner = byeWinner;\n/**\n * Returns the pre-computed winner for a match because of BYEs in a lower bracket.\n *\n * @param opponents Two opponents.\n */\nfunction byeWinnerToGrandFinal(opponents) {\n    const winner = byeWinner(opponents);\n    if (winner)\n        winner.position = 1;\n    return winner;\n}\nexports.byeWinnerToGrandFinal = byeWinnerToGrandFinal;\n/**\n * Returns the pre-computed loser for a match because of BYEs.\n *\n * Only used for loser bracket.\n *\n * @param opponents Two opponents.\n * @param index The index of the duel in the round.\n */\nfunction byeLoser(opponents, index) {\n    if (opponents[0] === null || opponents[1] === null) // At least one BYE.\n        return null; // BYE.\n    return { id: null, position: index + 1 }; // Normal.\n}\nexports.byeLoser = byeLoser;\n/**\n * Returns the winner side or `null` if no winner.\n *\n * @param match A match's results.\n */\nfunction getMatchResult(match) {\n    var _a, _b;\n    if (!isMatchCompleted(match))\n        return null;\n    if (isMatchDrawCompleted(match))\n        return null;\n    if (match.opponent1 === null && match.opponent2 === null)\n        return null;\n    let winner = null;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'win' || match.opponent2 === null || match.opponent2.forfeit)\n        winner = 'opponent1';\n    if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'win' || match.opponent1 === null || match.opponent1.forfeit) {\n        if (winner !== null)\n            throw Error('There are two winners.');\n        winner = 'opponent2';\n    }\n    return winner;\n}\nexports.getMatchResult = getMatchResult;\n/**\n * Finds a position in a list of matches.\n *\n * @param matches A list of matches to search into.\n * @param position The position to find.\n */\nfunction findPosition(matches, position) {\n    var _a, _b;\n    for (const match of matches) {\n        if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) === position)\n            return match.opponent1;\n        if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) === position)\n            return match.opponent2;\n    }\n    return null;\n}\nexports.findPosition = findPosition;\n/**\n * Gets the side where the winner of the given match will go in the next match.\n *\n * @param matchNumber Number of the match.\n */\nfunction getSide(matchNumber) {\n    return matchNumber % 2 === 1 ? 'opponent1' : 'opponent2';\n}\nexports.getSide = getSide;\n/**\n * Gets the other side of a match.\n *\n * @param side The side that we don't want.\n */\nfunction getOtherSide(side) {\n    return side === 'opponent1' ? 'opponent2' : 'opponent1';\n}\nexports.getOtherSide = getOtherSide;\n/**\n * Checks if a match is started.\n *\n * @param match Partial match results.\n */\nfunction isMatchStarted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.score) !== undefined || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.score) !== undefined;\n}\nexports.isMatchStarted = isMatchStarted;\n/**\n * Checks if a match is completed.\n *\n * @param match Partial match results.\n */\nfunction isMatchCompleted(match) {\n    return isMatchByeCompleted(match) || isMatchForfeitCompleted(match) || isMatchResultCompleted(match);\n}\nexports.isMatchCompleted = isMatchCompleted;\n/**\n * Checks if a match is completed because of a forfeit.\n *\n * @param match Partial match results.\n */\nfunction isMatchForfeitCompleted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.forfeit) !== undefined || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.forfeit) !== undefined;\n}\nexports.isMatchForfeitCompleted = isMatchForfeitCompleted;\n/**\n * Checks if a match is completed because of a either a draw or a win.\n *\n * @param match Partial match results.\n */\nfunction isMatchResultCompleted(match) {\n    return isMatchDrawCompleted(match) || isMatchWinCompleted(match);\n}\nexports.isMatchResultCompleted = isMatchResultCompleted;\n/**\n * Checks if a match is completed because of a draw.\n *\n * @param match Partial match results.\n */\nfunction isMatchDrawCompleted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'draw' && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'draw';\n}\nexports.isMatchDrawCompleted = isMatchDrawCompleted;\n/**\n * Checks if a match is completed because of a win.\n *\n * @param match Partial match results.\n */\nfunction isMatchWinCompleted(match) {\n    var _a, _b, _c, _d;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'win' || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'win'\n        || ((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.result) === 'loss' || ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.result) === 'loss';\n}\nexports.isMatchWinCompleted = isMatchWinCompleted;\n/**\n * Checks if a match is completed because of at least one BYE.\n *\n * A match \"BYE vs. TBD\" isn't considered completed yet.\n *\n * @param match Partial match results.\n */\nfunction isMatchByeCompleted(match) {\n    var _a, _b;\n    return (match.opponent1 === null && ((_a = match.opponent2) === null || _a === void 0 ? void 0 : _a.id) !== null) // BYE vs. someone\n        || (match.opponent2 === null && ((_b = match.opponent1) === null || _b === void 0 ? void 0 : _b.id) !== null) // someone vs. BYE\n        || (match.opponent1 === null && match.opponent2 === null); // BYE vs. BYE\n}\nexports.isMatchByeCompleted = isMatchByeCompleted;\n/**\n * Checks if a match's results can't be updated.\n *\n * @param match The match to check.\n */\nfunction isMatchUpdateLocked(match) {\n    return match.status === brackets_model_1.Status.Locked || match.status === brackets_model_1.Status.Waiting || match.status === brackets_model_1.Status.Archived;\n}\nexports.isMatchUpdateLocked = isMatchUpdateLocked;\n/**\n * Checks if a match's participants can't be updated.\n *\n * @param match The match to check.\n */\nfunction isMatchParticipantLocked(match) {\n    return match.status >= brackets_model_1.Status.Running;\n}\nexports.isMatchParticipantLocked = isMatchParticipantLocked;\n/**\n * Indicates whether a match has at least one BYE or not.\n *\n * @param match Partial match results.\n */\nfunction hasBye(match) {\n    return match.opponent1 === null || match.opponent2 === null;\n}\nexports.hasBye = hasBye;\n/**\n * Returns the status of a match based on information about it.\n *\n * @param arg The opponents or partial results of the match.\n */\nfunction getMatchStatus(arg) {\n    var _a, _b, _c, _d;\n    const match = Array.isArray(arg) ? {\n        opponent1: arg[0],\n        opponent2: arg[1],\n    } : arg;\n    if (hasBye(match)) // At least one BYE.\n        return brackets_model_1.Status.Locked;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id) === null && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id) === null) // Two TBD opponents.\n        return brackets_model_1.Status.Locked;\n    if (((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.id) === null || ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.id) === null) // One TBD opponent.\n        return brackets_model_1.Status.Waiting;\n    if (isMatchCompleted(match))\n        return brackets_model_1.Status.Completed;\n    if (isMatchStarted(match))\n        return brackets_model_1.Status.Running;\n    return brackets_model_1.Status.Ready;\n}\nexports.getMatchStatus = getMatchStatus;\n/**\n * Updates a match results based on an input.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @param inRoundRobin Indicates whether the match is in a round-robin stage.\n */\nfunction setMatchResults(stored, match, inRoundRobin) {\n    const completed = isMatchCompleted(match);\n    const currentlyCompleted = isMatchCompleted(stored);\n    handleOpponentsInversion(stored, match);\n    const statusChanged = setScores(stored, match);\n    if (completed && currentlyCompleted) {\n        // Ensure everything is good.\n        setCompleted(stored, match, inRoundRobin);\n        return { statusChanged: false, resultChanged: true };\n    }\n    if (completed && !currentlyCompleted) {\n        setCompleted(stored, match, inRoundRobin);\n        return { statusChanged: true, resultChanged: true };\n    }\n    if (!completed && currentlyCompleted) {\n        resetMatchResults(stored);\n        return { statusChanged: true, resultChanged: true };\n    }\n    return { statusChanged, resultChanged: false };\n}\nexports.setMatchResults = setMatchResults;\n/**\n * Resets the results of a match. (status, forfeit, result)\n *\n * @param stored A reference to what will be updated in the storage.\n */\nfunction resetMatchResults(stored) {\n    if (stored.opponent1) {\n        stored.opponent1.forfeit = undefined;\n        stored.opponent1.result = undefined;\n    }\n    if (stored.opponent2) {\n        stored.opponent2.forfeit = undefined;\n        stored.opponent2.result = undefined;\n    }\n    stored.status = getMatchStatus(stored);\n}\nexports.resetMatchResults = resetMatchResults;\n/**\n * Gets the id of the opponent at the given side of the given match.\n *\n * @param match The match to get the opponent from.\n * @param side The side where to get the opponent from.\n */\nfunction getOpponentId(match, side) {\n    const opponent = match[side];\n    return opponent && opponent.id;\n}\nexports.getOpponentId = getOpponentId;\n/**\n * Gets the origin position of a side of a match.\n *\n * @param match The match.\n * @param side The side.\n */\nfunction getOriginPosition(match, side) {\n    var _a;\n    const matchNumber = (_a = match[side]) === null || _a === void 0 ? void 0 : _a.position;\n    if (matchNumber === undefined)\n        throw Error('Position is undefined.');\n    return matchNumber;\n}\nexports.getOriginPosition = getOriginPosition;\n/**\n * Returns every loser in a list of matches.\n *\n * @param participants The list of participants.\n * @param matches A list of matches to get losers of.\n */\nfunction getLosers(participants, matches) {\n    const losers = [];\n    let currentRound = null;\n    let roundIndex = -1;\n    for (const match of matches) {\n        if (match.round_id !== currentRound) {\n            currentRound = match.round_id;\n            roundIndex++;\n            losers[roundIndex] = [];\n        }\n        const loser = getLoser(match);\n        if (loser === null)\n            continue;\n        losers[roundIndex].push(findParticipant(participants, loser));\n    }\n    return losers;\n}\nexports.getLosers = getLosers;\n/**\n * Makes final standings based on participants grouped by ranking.\n *\n * @param grouped A list of participants grouped by ranking.\n */\nfunction makeFinalStandings(grouped) {\n    const standings = [];\n    let rank = 1;\n    for (const group of grouped) {\n        for (const participant of group) {\n            standings.push({\n                id: participant.id,\n                name: participant.name,\n                rank,\n            });\n        }\n        rank++;\n    }\n    return standings;\n}\nexports.makeFinalStandings = makeFinalStandings;\n/**\n * Returns the decisive match of a Grand Final.\n *\n * @param type The type of Grand Final.\n * @param matches The matches in the Grand Final.\n */\nfunction getGrandFinalDecisiveMatch(type, matches) {\n    if (type === 'simple')\n        return matches[0];\n    if (type === 'double') {\n        const result = getMatchResult(matches[0]);\n        if (result === 'opponent2')\n            return matches[1];\n        return matches[0];\n    }\n    throw Error('The Grand Final is disabled.');\n}\nexports.getGrandFinalDecisiveMatch = getGrandFinalDecisiveMatch;\n/**\n * Finds a participant in a list.\n *\n * @param participants The list of participants.\n * @param slot The slot of the participant to find.\n */\nfunction findParticipant(participants, slot) {\n    const participant = participants.find(participant => participant.id === (slot === null || slot === void 0 ? void 0 : slot.id));\n    if (!participant)\n        throw Error('Participant not found.');\n    return participant;\n}\nexports.findParticipant = findParticipant;\n/**\n * Gets the side the winner of the current match will go to in the next match.\n *\n * @param matchNumber Number of the current match.\n * @param roundNumber Number of the current round.\n * @param roundCount Count of rounds.\n * @param matchLocation Location of the current match.\n */\nfunction getNextSide(matchNumber, roundNumber, roundCount, matchLocation) {\n    // The nextSide comes from the same bracket.\n    if (matchLocation === 'loser_bracket' && roundNumber % 2 === 1)\n        return 'opponent2';\n    // The nextSide comes from the loser bracket to the final group.\n    if (matchLocation === 'loser_bracket' && roundNumber === roundCount)\n        return 'opponent2';\n    return getSide(matchNumber);\n}\nexports.getNextSide = getNextSide;\n/**\n * Gets the side the winner of the current match in loser bracket will go in the next match.\n *\n * @param matchNumber Number of the match.\n * @param nextMatch The next match.\n * @param roundNumber Number of the current round.\n */\nfunction getNextSideLoserBracket(matchNumber, nextMatch, roundNumber) {\n    var _a;\n    // The nextSide comes from the WB.\n    if (roundNumber > 1)\n        return 'opponent1';\n    // The nextSide comes from the WB round 1. \n    if (((_a = nextMatch.opponent1) === null || _a === void 0 ? void 0 : _a.position) === matchNumber)\n        return 'opponent1';\n    return 'opponent2';\n}\nexports.getNextSideLoserBracket = getNextSideLoserBracket;\n/**\n * Sets an opponent in the next match he has to go.\n *\n * @param nextMatch A match which follows the current one.\n * @param nextSide The side the opponent will be on in the next match.\n * @param match The current match.\n * @param currentSide The side the opponent is currently on.\n */\nfunction setNextOpponent(nextMatch, nextSide, match, currentSide) {\n    var _a;\n    nextMatch[nextSide] = match[currentSide] && {\n        id: getOpponentId(match, currentSide),\n        position: (_a = nextMatch[nextSide]) === null || _a === void 0 ? void 0 : _a.position, // Keep position.\n    };\n    nextMatch.status = getMatchStatus(nextMatch);\n}\nexports.setNextOpponent = setNextOpponent;\n/**\n * Resets an opponent in the match following the current one.\n *\n * @param nextMatch A match which follows the current one.\n * @param nextSide The side the opponent will be on in the next match.\n */\nfunction resetNextOpponent(nextMatch, nextSide) {\n    var _a;\n    nextMatch[nextSide] = nextMatch[nextSide] && {\n        id: null,\n        position: (_a = nextMatch[nextSide]) === null || _a === void 0 ? void 0 : _a.position, // Keep position.\n    };\n    nextMatch.status = brackets_model_1.Status.Locked;\n}\nexports.resetNextOpponent = resetNextOpponent;\n/**\n * Inverts opponents if requested by the input.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction handleOpponentsInversion(stored, match) {\n    var _a, _b, _c, _d;\n    const id1 = (_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id;\n    const id2 = (_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id;\n    const storedId1 = (_c = stored.opponent1) === null || _c === void 0 ? void 0 : _c.id;\n    const storedId2 = (_d = stored.opponent2) === null || _d === void 0 ? void 0 : _d.id;\n    if (Number.isInteger(id1) && id1 !== storedId1 && id1 !== storedId2)\n        throw Error('The given opponent1 ID does not exist in this match.');\n    if (Number.isInteger(id2) && id2 !== storedId1 && id2 !== storedId2)\n        throw Error('The given opponent2 ID does not exist in this match.');\n    if (Number.isInteger(id1) && id1 === storedId2 || Number.isInteger(id2) && id2 === storedId1)\n        invertOpponents(match);\n}\nexports.handleOpponentsInversion = handleOpponentsInversion;\n/**\n * Inverts `opponent1` and `opponent2` in a match.\n *\n * @param match A match to update.\n */\nfunction invertOpponents(match) {\n    [match.opponent1, match.opponent2] = [match.opponent2, match.opponent1];\n}\nexports.invertOpponents = invertOpponents;\n/**\n * Updates the scores of a match.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @returns `true` if the status of the match changed, `false` otherwise.\n */\nfunction setScores(stored, match) {\n    var _a, _b, _c, _d;\n    // Skip if no score update.\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.score) === ((_b = stored.opponent1) === null || _b === void 0 ? void 0 : _b.score) && ((_c = match.opponent2) === null || _c === void 0 ? void 0 : _c.score) === ((_d = stored.opponent2) === null || _d === void 0 ? void 0 : _d.score))\n        return false;\n    const oldStatus = stored.status;\n    stored.status = brackets_model_1.Status.Running;\n    if (match.opponent1 && stored.opponent1)\n        stored.opponent1.score = match.opponent1.score;\n    if (match.opponent2 && stored.opponent2)\n        stored.opponent2.score = match.opponent2.score;\n    return stored.status !== oldStatus;\n}\nexports.setScores = setScores;\n/**\n * Completes a match and handles results and forfeits.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @param inRoundRobin Indicates whether the match is in a round-robin stage.\n */\nfunction setCompleted(stored, match, inRoundRobin) {\n    stored.status = brackets_model_1.Status.Completed;\n    setResults(stored, match, 'win', 'loss', inRoundRobin);\n    setResults(stored, match, 'loss', 'win', inRoundRobin);\n    setResults(stored, match, 'draw', 'draw', inRoundRobin);\n    if (stored.opponent1 && !stored.opponent2)\n        stored.opponent1.result = 'win'; // Win against opponent 2 BYE.\n    if (!stored.opponent1 && stored.opponent2)\n        stored.opponent2.result = 'win'; // Win against opponent 1 BYE.\n    setForfeits(stored, match);\n}\nexports.setCompleted = setCompleted;\n/**\n * Enforces the symmetry between opponents.\n *\n * Sets an opponent's result to something, based on the result on the other opponent.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @param check A result to check in each opponent.\n * @param change A result to set in each other opponent if `check` is correct.\n * @param inRoundRobin Indicates whether the match is in a round-robin stage.\n */\nfunction setResults(stored, match, check, change, inRoundRobin) {\n    var _a, _b;\n    if (match.opponent1 && match.opponent2) {\n        if (match.opponent1.result === 'win' && match.opponent2.result === 'win')\n            throw Error('There are two winners.');\n        if (match.opponent1.result === 'loss' && match.opponent2.result === 'loss')\n            throw Error('There are two losers.');\n        if (!inRoundRobin && match.opponent1.forfeit === true && match.opponent2.forfeit === true)\n            throw Error('There are two forfeits.');\n    }\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === check) {\n        if (stored.opponent1)\n            stored.opponent1.result = check;\n        else\n            stored.opponent1 = { id: null, result: check };\n        if (stored.opponent2)\n            stored.opponent2.result = change;\n        else\n            stored.opponent2 = { id: null, result: change };\n    }\n    if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === check) {\n        if (stored.opponent2)\n            stored.opponent2.result = check;\n        else\n            stored.opponent2 = { id: null, result: check };\n        if (stored.opponent1)\n            stored.opponent1.result = change;\n        else\n            stored.opponent1 = { id: null, result: change };\n    }\n}\nexports.setResults = setResults;\n/**\n * Sets forfeits for each opponent (if needed).\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction setForfeits(stored, match) {\n    var _a, _b, _c, _d;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.forfeit) === true && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.forfeit) === true) {\n        if (stored.opponent1)\n            stored.opponent1.forfeit = true;\n        if (stored.opponent2)\n            stored.opponent2.forfeit = true;\n        // Don't set any result (win/draw/loss) with a double forfeit \n        // so that it doesn't count any point in the ranking.\n        return;\n    }\n    if (((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.forfeit) === true) {\n        if (stored.opponent1)\n            stored.opponent1.forfeit = true;\n        if (stored.opponent2)\n            stored.opponent2.result = 'win';\n        else\n            stored.opponent2 = { id: null, result: 'win' };\n    }\n    if (((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.forfeit) === true) {\n        if (stored.opponent2)\n            stored.opponent2.forfeit = true;\n        if (stored.opponent1)\n            stored.opponent1.result = 'win';\n        else\n            stored.opponent1 = { id: null, result: 'win' };\n    }\n}\nexports.setForfeits = setForfeits;\n/**\n * Indicates if a seeding is filled with participants' names or IDs.\n *\n * @param seeding The seeding.\n */\nfunction isSeedingWithIds(seeding) {\n    return seeding.some((value) => typeof value === 'number');\n}\nexports.isSeedingWithIds = isSeedingWithIds;\n/**\n * Extracts participants from a seeding, without the byes.\n *\n * @param tournamentId ID of the tournament.\n * @param seeding The seeding.\n */\nfunction extractParticipantsFromSeeding(tournamentId, seeding) {\n    const withoutByes = seeding.filter(name => name !== null);\n    const participants = withoutByes.map(name => ({\n        tournament_id: tournamentId,\n        name,\n    }));\n    return participants;\n}\nexports.extractParticipantsFromSeeding = extractParticipantsFromSeeding;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to their name.\n *\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsNamesToDatabase(seeding, database, positions) {\n    return mapParticipantsToDatabase('name', seeding, database, positions);\n}\nexports.mapParticipantsNamesToDatabase = mapParticipantsNamesToDatabase;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to their id.\n *\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsIdsToDatabase(seeding, database, positions) {\n    return mapParticipantsToDatabase('id', seeding, database, positions);\n}\nexports.mapParticipantsIdsToDatabase = mapParticipantsIdsToDatabase;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to a property of theirs.\n *\n * @param prop The property to search participants with.\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsToDatabase(prop, seeding, database, positions) {\n    const slots = seeding.map((slot, i) => {\n        if (slot === null)\n            return null; // BYE.\n        const found = database.find(participant => participant[prop] === slot);\n        if (!found)\n            throw Error(`Participant ${prop} not found in database.`);\n        return { id: found.id, position: i + 1 };\n    });\n    if (!positions)\n        return slots;\n    if (positions.length !== slots.length)\n        throw Error('Not enough seeds in at least one group of the manual ordering.');\n    return positions.map(position => slots[position - 1]); // position = i + 1\n}\nexports.mapParticipantsToDatabase = mapParticipantsToDatabase;\n/**\n * Converts a list of matches to a seeding.\n *\n * @param matches The input matches.\n */\nfunction convertMatchesToSeeding(matches) {\n    const flattened = [].concat(...matches.map(match => [match.opponent1, match.opponent2]));\n    return sortSeeding(flattened);\n}\nexports.convertMatchesToSeeding = convertMatchesToSeeding;\n/**\n * Converts a list of slots to an input seeding.\n *\n * @param slots The slots to convert.\n */\nfunction convertSlotsToSeeding(slots) {\n    return slots.map(slot => {\n        if (slot === null || slot.id === null)\n            return null; // BYE or TBD.\n        return slot.id; // Let's return the ID instead of the name to be sure we keep the same reference.\n    });\n}\nexports.convertSlotsToSeeding = convertSlotsToSeeding;\n/**\n * Sorts the seeding with the BYEs in the correct position.\n *\n * @param slots A list of slots to sort.\n */\nfunction sortSeeding(slots) {\n    const withoutByes = slots.filter(v => v !== null);\n    // a and b are not null because of the filter.\n    // The slots are from seeding slots, thus they have a position.\n    withoutByes.sort((a, b) => a.position - b.position);\n    if (withoutByes.length === slots.length)\n        return withoutByes;\n    // Same for v and position.\n    const placed = Object.fromEntries(withoutByes.map(v => [v.position - 1, v]));\n    const sortedWithByes = Array.from({ length: slots.length }, (_, i) => placed[i] || null);\n    return sortedWithByes;\n}\nexports.sortSeeding = sortSeeding;\n/**\n * Returns only the non null elements.\n *\n * @param array The array to process.\n */\nfunction getNonNull(array) {\n    // Use a TS type guard to exclude null from the resulting type.\n    const nonNull = array.filter((element) => element !== null);\n    return nonNull;\n}\nexports.getNonNull = getNonNull;\n/**\n * Returns a list of objects which have unique values of a specific key.\n *\n * @param array The array to process.\n * @param key The key to filter by.\n */\nfunction uniqueBy(array, key) {\n    const seen = new Set();\n    return array.filter(item => {\n        const value = key(item);\n        if (!value)\n            return true;\n        if (seen.has(value))\n            return false;\n        seen.add(value);\n        return true;\n    });\n}\nexports.uniqueBy = uniqueBy;\n/**\n * Makes the transition to a major round for duels of the previous round. The duel count is divided by 2.\n *\n * @param previousDuels The previous duels to transition from.\n */\nfunction transitionToMajor(previousDuels) {\n    const currentDuelCount = previousDuels.length / 2;\n    const currentDuels = [];\n    for (let duelIndex = 0; duelIndex < currentDuelCount; duelIndex++) {\n        const prevDuelId = duelIndex * 2;\n        currentDuels.push([\n            byeWinner(previousDuels[prevDuelId]),\n            byeWinner(previousDuels[prevDuelId + 1]),\n        ]);\n    }\n    return currentDuels;\n}\nexports.transitionToMajor = transitionToMajor;\n/**\n * Makes the transition to a minor round for duels of the previous round. The duel count stays the same.\n *\n * @param previousDuels The previous duels to transition from.\n * @param losers Losers from the previous major round.\n * @param method The ordering method for the losers.\n */\nfunction transitionToMinor(previousDuels, losers, method) {\n    const orderedLosers = method ? ordering_1.ordering[method](losers) : losers;\n    const currentDuelCount = previousDuels.length;\n    const currentDuels = [];\n    for (let duelIndex = 0; duelIndex < currentDuelCount; duelIndex++) {\n        const prevDuelId = duelIndex;\n        currentDuels.push([\n            orderedLosers[prevDuelId],\n            byeWinner(previousDuels[prevDuelId]),\n        ]);\n    }\n    return currentDuels;\n}\nexports.transitionToMinor = transitionToMinor;\n/**\n * Sets the parent match to a completed status if all its child games are completed.\n *\n * @param parent The partial parent match to update.\n * @param childCount Child count of this parent match.\n * @param inRoundRobin Indicates whether the parent match is in a round-robin stage.\n */\nfunction setParentMatchCompleted(parent, childCount, inRoundRobin) {\n    var _a, _b;\n    if (((_a = parent.opponent1) === null || _a === void 0 ? void 0 : _a.score) === undefined || ((_b = parent.opponent2) === null || _b === void 0 ? void 0 : _b.score) === undefined)\n        throw Error('Either opponent1, opponent2 or their scores are falsy.');\n    const minToWin = minScoreToWinBestOfX(childCount);\n    if (parent.opponent1.score >= minToWin) {\n        parent.opponent1.result = 'win';\n        return;\n    }\n    if (parent.opponent2.score >= minToWin) {\n        parent.opponent2.result = 'win';\n        return;\n    }\n    if (parent.opponent1.score === parent.opponent2.score && parent.opponent1.score + parent.opponent2.score > childCount - 1) {\n        if (inRoundRobin) {\n            parent.opponent1.result = 'draw';\n            parent.opponent2.result = 'draw';\n            return;\n        }\n        throw Error('Match games result in a tie for the parent match.');\n    }\n}\nexports.setParentMatchCompleted = setParentMatchCompleted;\n/**\n * Returns a parent match results based on its child games scores.\n *\n * @param storedParent The parent match stored in the database.\n * @param scores The scores of the match child games.\n */\nfunction getParentMatchResults(storedParent, scores) {\n    return {\n        opponent1: {\n            id: storedParent.opponent1 && storedParent.opponent1.id,\n            score: scores.opponent1,\n        },\n        opponent2: {\n            id: storedParent.opponent2 && storedParent.opponent2.id,\n            score: scores.opponent2,\n        },\n    };\n}\nexports.getParentMatchResults = getParentMatchResults;\n/**\n * Gets the values which need to be updated in a match when it's updated on insertion.\n *\n * @param match The up to date match.\n * @param existing The base match.\n * @param enableByes Whether to use BYEs or TBDs for `null` values in an input seeding.\n */\nfunction getUpdatedMatchResults(match, existing, enableByes) {\n    return {\n        ...existing,\n        ...match,\n        ...(enableByes ? {\n            opponent1: match.opponent1 === null ? null : { ...existing.opponent1, ...match.opponent1 },\n            opponent2: match.opponent2 === null ? null : { ...existing.opponent2, ...match.opponent2 },\n        } : {\n            opponent1: match.opponent1 === null ? { id: null } : { ...existing.opponent1, ...match.opponent1 },\n            opponent2: match.opponent2 === null ? { id: null } : { ...existing.opponent2, ...match.opponent2 },\n        }),\n    };\n}\nexports.getUpdatedMatchResults = getUpdatedMatchResults;\n/**\n * Calculates the score of a parent match based on its child games.\n *\n * @param games The child games to process.\n */\nfunction getChildGamesResults(games) {\n    const scores = {\n        opponent1: 0,\n        opponent2: 0,\n    };\n    for (const game of games) {\n        const result = getMatchResult(game);\n        if (result === 'opponent1')\n            scores.opponent1++;\n        else if (result === 'opponent2')\n            scores.opponent2++;\n    }\n    return scores;\n}\nexports.getChildGamesResults = getChildGamesResults;\n/**\n * Gets the default list of seeds for a round's matches.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the current round.\n * @param roundCountLB The count of rounds in loser bracket.\n * @param matchCount The count of matches in the round.\n */\nfunction getSeeds(inLoserBracket, roundNumber, roundCountLB, matchCount) {\n    const seedCount = getSeedCount(inLoserBracket, roundNumber, roundCountLB, matchCount);\n    return Array.from(Array(seedCount), (_, i) => i + 1);\n}\nexports.getSeeds = getSeeds;\n/**\n * Gets the number of seeds for a round's matches.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the current round.\n * @param roundCountLB The count of rounds in loser bracket.\n * @param matchCount The count of matches in the round.\n */\nfunction getSeedCount(inLoserBracket, roundNumber, roundCountLB, matchCount) {\n    ensureOrderingSupported(inLoserBracket, roundNumber, roundCountLB);\n    return roundNumber === 1 ?\n        matchCount * 2 : // Two per match for upper or lower bracket round 1.\n        matchCount; // One per match for loser bracket minor rounds.\n}\nexports.getSeedCount = getSeedCount;\n/**\n * Throws if the ordering is not supported on the given round number.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the round.\n * @param roundCountLB The count of rounds in loser bracket.\n */\nfunction ensureOrderingSupported(inLoserBracket, roundNumber, roundCountLB) {\n    if (inLoserBracket && !isOrderingSupportedLoserBracket(roundNumber, roundCountLB))\n        throw Error('This round does not support ordering.');\n    if (!inLoserBracket && !isOrderingSupportedUpperBracket(roundNumber))\n        throw Error('This round does not support ordering.');\n}\nexports.ensureOrderingSupported = ensureOrderingSupported;\n/**\n * Indicates whether the ordering is supported in upper bracket, given the round number.\n *\n * @param roundNumber The number of the round.\n */\nfunction isOrderingSupportedUpperBracket(roundNumber) {\n    return roundNumber === 1;\n}\nexports.isOrderingSupportedUpperBracket = isOrderingSupportedUpperBracket;\n/**\n * Indicates whether the ordering is supported in loser bracket, given the round number.\n *\n * @param roundNumber The number of the round.\n * @param roundCount The count of rounds.\n */\nfunction isOrderingSupportedLoserBracket(roundNumber, roundCount) {\n    return roundNumber === 1 || (roundNumber % 2 === 0 && roundNumber < roundCount);\n}\nexports.isOrderingSupportedLoserBracket = isOrderingSupportedLoserBracket;\n/**\n * Returns the number of rounds an upper bracket has given the number of participants in the stage.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction getUpperBracketRoundCount(participantCount) {\n    return Math.log2(participantCount);\n}\nexports.getUpperBracketRoundCount = getUpperBracketRoundCount;\n/**\n * Returns the count of round pairs (major & minor) in a loser bracket.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction getRoundPairCount(participantCount) {\n    return getUpperBracketRoundCount(participantCount) - 1;\n}\nexports.getRoundPairCount = getRoundPairCount;\n/**\n * Determines whether a double elimination stage is really necessary.\n *\n * If the size is only two (less is impossible), then a lower bracket and a grand final are not necessary.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction isDoubleEliminationNecessary(participantCount) {\n    return participantCount > 2;\n}\nexports.isDoubleEliminationNecessary = isDoubleEliminationNecessary;\n/**\n * Returns the real (because of loser ordering) number of a match in a loser bracket.\n *\n * @param participantCount The number of participants in a stage.\n * @param roundNumber Number of the round.\n * @param matchNumber Number of the match.\n * @param method The method used for the round.\n */\nfunction findLoserMatchNumber(participantCount, roundNumber, matchNumber, method) {\n    const loserCount = getLoserRoundLoserCount(participantCount, roundNumber);\n    const losers = Array.from(Array(loserCount), (_, i) => i + 1);\n    const ordered = method ? ordering_1.ordering[method](losers) : losers;\n    const matchNumberLB = ordered.indexOf(matchNumber) + 1;\n    // For LB round 1, the list of losers is spread over the matches 2 by 2.\n    if (roundNumber === 1)\n        return Math.ceil(matchNumberLB / 2);\n    return matchNumberLB;\n}\nexports.findLoserMatchNumber = findLoserMatchNumber;\n/**\n * Returns the count of matches in a round of a loser bracket.\n *\n * @param participantCount The number of participants in a stage.\n * @param roundNumber Number of the round.\n */\nfunction getLoserRoundMatchCount(participantCount, roundNumber) {\n    const roundPairIndex = Math.ceil(roundNumber / 2) - 1;\n    const roundPairCount = getRoundPairCount(participantCount);\n    const matchCount = Math.pow(2, roundPairCount - roundPairIndex - 1);\n    return matchCount;\n}\nexports.getLoserRoundMatchCount = getLoserRoundMatchCount;\n/**\n * Returns the count of losers in a round of a loser bracket.\n *\n * @param participantCount The number of participants in a stage.\n * @param roundNumber Number of the round.\n */\nfunction getLoserRoundLoserCount(participantCount, roundNumber) {\n    const matchCount = getLoserRoundMatchCount(participantCount, roundNumber);\n    // Two per match for LB round 1 (losers coming from WB round 1).\n    if (roundNumber === 1)\n        return matchCount * 2;\n    return matchCount; // One per match for LB minor rounds.\n}\nexports.getLoserRoundLoserCount = getLoserRoundLoserCount;\n/**\n * Returns the ordering method of a round of a loser bracket.\n *\n * @param seedOrdering The list of seed orderings.\n * @param roundNumber Number of the round.\n */\nfunction getLoserOrdering(seedOrdering, roundNumber) {\n    const orderingIndex = 1 + Math.floor(roundNumber / 2);\n    return seedOrdering[orderingIndex];\n}\nexports.getLoserOrdering = getLoserOrdering;\n/**\n * Returns the number of rounds a lower bracket has given the number of participants in a double elimination stage.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction getLowerBracketRoundCount(participantCount) {\n    const roundPairCount = getRoundPairCount(participantCount);\n    return roundPairCount * 2;\n}\nexports.getLowerBracketRoundCount = getLowerBracketRoundCount;\n/**\n * Returns the match number of the corresponding match in the next round by dividing by two.\n *\n * @param matchNumber The current match number.\n */\nfunction getDiagonalMatchNumber(matchNumber) {\n    return Math.ceil(matchNumber / 2);\n}\nexports.getDiagonalMatchNumber = getDiagonalMatchNumber;\n/**\n * Returns the nearest power of two **greater than** or equal to the given number.\n *\n * @param input The input number.\n */\nfunction getNearestPowerOfTwo(input) {\n    return Math.pow(2, Math.ceil(Math.log2(input)));\n}\nexports.getNearestPowerOfTwo = getNearestPowerOfTwo;\n/**\n * Returns the minimum score a participant must have to win a Best Of X series match.\n *\n * @param x The count of child games in the series.\n */\nfunction minScoreToWinBestOfX(x) {\n    return (x + 1) / 2;\n}\nexports.minScoreToWinBestOfX = minScoreToWinBestOfX;\n/**\n * Checks if a stage is a round-robin stage.\n *\n * @param stage The stage to check.\n */\nfunction isRoundRobin(stage) {\n    return stage.type === 'round_robin';\n}\nexports.isRoundRobin = isRoundRobin;\n/**\n * Throws if a stage is round-robin.\n *\n * @param stage The stage to check.\n */\nfunction ensureNotRoundRobin(stage) {\n    const inRoundRobin = isRoundRobin(stage);\n    if (inRoundRobin)\n        throw Error('Impossible to update ordering in a round-robin stage.');\n}\nexports.ensureNotRoundRobin = ensureNotRoundRobin;\n/**\n * Checks if a group is a winner bracket.\n *\n * It's not always the opposite of `inLoserBracket()`: it could be the only bracket of a single elimination stage.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isWinnerBracket(stageType, groupNumber) {\n    return stageType === 'double_elimination' && groupNumber === 1;\n}\nexports.isWinnerBracket = isWinnerBracket;\n/**\n * Checks if a group is a loser bracket.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isLoserBracket(stageType, groupNumber) {\n    return stageType === 'double_elimination' && groupNumber === 2;\n}\nexports.isLoserBracket = isLoserBracket;\n/**\n * Checks if a group is a final group (consolation final or grand final).\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isFinalGroup(stageType, groupNumber) {\n    return stageType === 'single_elimination' && groupNumber === 2 ||\n        stageType === 'double_elimination' && groupNumber === 3;\n}\nexports.isFinalGroup = isFinalGroup;\n/**\n * Returns the type of group the match is located into.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction getMatchLocation(stageType, groupNumber) {\n    if (isWinnerBracket(stageType, groupNumber))\n        return 'winner_bracket';\n    if (isLoserBracket(stageType, groupNumber))\n        return 'loser_bracket';\n    if (isFinalGroup(stageType, groupNumber))\n        return 'final_group';\n    return 'single_bracket';\n}\nexports.getMatchLocation = getMatchLocation;\n//# sourceMappingURL=helpers.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/helpers.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.helpers = exports.BracketsManager = void 0;\nconst manager_1 = __webpack_require__(/*! ./manager */ \"./node_modules/brackets-manager/dist/manager.js\");\nObject.defineProperty(exports, \"BracketsManager\", ({ enumerable: true, get: function () { return manager_1.BracketsManager; } }));\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nexports.helpers = {\n    getWinner: helpers_1.getWinner,\n    getLoser: helpers_1.getLoser,\n    getMatchResult: helpers_1.getMatchResult,\n    isMatchStarted: helpers_1.isMatchStarted,\n    isMatchCompleted: helpers_1.isMatchCompleted,\n    isMatchForfeitCompleted: helpers_1.isMatchForfeitCompleted,\n    isMatchResultCompleted: helpers_1.isMatchResultCompleted,\n    isMatchDrawCompleted: helpers_1.isMatchDrawCompleted,\n    isMatchWinCompleted: helpers_1.isMatchWinCompleted,\n    isMatchByeCompleted: helpers_1.isMatchByeCompleted,\n    isMatchUpdateLocked: helpers_1.isMatchUpdateLocked,\n    isMatchParticipantLocked: helpers_1.isMatchParticipantLocked,\n    hasBye: helpers_1.hasBye,\n    getUpperBracketRoundCount: helpers_1.getUpperBracketRoundCount,\n    getRoundPairCount: helpers_1.getRoundPairCount,\n    getLoserRoundMatchCount: helpers_1.getLoserRoundMatchCount,\n    getLoserRoundLoserCount: helpers_1.getLoserRoundLoserCount,\n    getLowerBracketRoundCount: helpers_1.getLowerBracketRoundCount,\n    getNearestPowerOfTwo: helpers_1.getNearestPowerOfTwo,\n    minScoreToWinBestOfX: helpers_1.minScoreToWinBestOfX,\n    isRoundRobin: helpers_1.isRoundRobin,\n    isWinnerBracket: helpers_1.isWinnerBracket,\n    isLoserBracket: helpers_1.isLoserBracket,\n    isFinalGroup: helpers_1.isFinalGroup,\n    getMatchLocation: helpers_1.getMatchLocation,\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/index.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/manager.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BracketsManager = void 0;\nconst create_1 = __webpack_require__(/*! ./create */ \"./node_modules/brackets-manager/dist/create.js\");\nconst get_1 = __webpack_require__(/*! ./get */ \"./node_modules/brackets-manager/dist/get.js\");\nconst update_1 = __webpack_require__(/*! ./update */ \"./node_modules/brackets-manager/dist/update.js\");\nconst delete_1 = __webpack_require__(/*! ./delete */ \"./node_modules/brackets-manager/dist/delete.js\");\nconst find_1 = __webpack_require__(/*! ./find */ \"./node_modules/brackets-manager/dist/find.js\");\nconst reset_1 = __webpack_require__(/*! ./reset */ \"./node_modules/brackets-manager/dist/reset.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\n/**\n * A class to handle tournament management at those levels: `stage`, `group`, `round`, `match` and `match_game`.\n */\nclass BracketsManager {\n    /**\n     * Creates an instance of BracketsManager, which will handle all the stuff from the library.\n     *\n     * @param storageInterface An implementation of CrudInterface.\n     */\n    constructor(storageInterface) {\n        const storage = storageInterface;\n        storage.selectFirst = async (table, filter) => {\n            const results = await this.storage.select(table, filter);\n            if (!results || results.length === 0)\n                return null;\n            return results[0];\n        };\n        storage.selectLast = async (table, filter) => {\n            const results = await this.storage.select(table, filter);\n            if (!results || results.length === 0)\n                return null;\n            return results[results.length - 1];\n        };\n        this.storage = storage;\n        this.get = new get_1.Get(this.storage);\n        this.update = new update_1.Update(this.storage);\n        this.delete = new delete_1.Delete(this.storage);\n        this.find = new find_1.Find(this.storage);\n        this.reset = new reset_1.Reset(this.storage);\n    }\n    /**\n     * Creates a stage for an existing tournament. The tournament won't be created.\n     *\n     * @param stage A stage to create.\n     */\n    async create(stage) {\n        await create_1.create.call(this, stage);\n    }\n    /**\n     * Imports data in the database.\n     *\n     * @param data Data to import.\n     * @param normalizeIds Enable ID normalization: all IDs (and references to them) are remapped to consecutive IDs starting from 0.\n     */\n    async import(data, normalizeIds = false) {\n        if (normalizeIds)\n            data = helpers.normalizeIds(data);\n        if (!await this.storage.delete('participant'))\n            throw Error('Could not empty the participant table.');\n        if (!await this.storage.insert('participant', data.participant))\n            throw Error('Could not import participants.');\n        if (!await this.storage.delete('stage'))\n            throw Error('Could not empty the stage table.');\n        if (!await this.storage.insert('stage', data.stage))\n            throw Error('Could not import stages.');\n        if (!await this.storage.delete('group'))\n            throw Error('Could not empty the group table.');\n        if (!await this.storage.insert('group', data.group))\n            throw Error('Could not import groups.');\n        if (!await this.storage.delete('round'))\n            throw Error('Could not empty the round table.');\n        if (!await this.storage.insert('round', data.round))\n            throw Error('Could not import rounds.');\n        if (!await this.storage.delete('match'))\n            throw Error('Could not empty the match table.');\n        if (!await this.storage.insert('match', data.match))\n            throw Error('Could not import matches.');\n        if (!await this.storage.delete('match_game'))\n            throw Error('Could not empty the match_game table.');\n        if (!await this.storage.insert('match_game', data.match_game))\n            throw Error('Could not import match games.');\n    }\n    /**\n     * Exports data from the database.\n     */\n    async export() {\n        const participants = await this.storage.select('participant');\n        if (!participants)\n            throw Error('Error getting participants.');\n        const stages = await this.storage.select('stage');\n        if (!stages)\n            throw Error('Error getting stages.');\n        const groups = await this.storage.select('group');\n        if (!groups)\n            throw Error('Error getting groups.');\n        const rounds = await this.storage.select('round');\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const matches = await this.storage.select('match');\n        if (!matches)\n            throw Error('Error getting matches.');\n        const matchGames = await this.get.matchGames(matches);\n        return {\n            participant: participants,\n            stage: stages,\n            group: groups,\n            round: rounds,\n            match: matches,\n            match_game: matchGames,\n        };\n    }\n}\nexports.BracketsManager = BracketsManager;\n//# sourceMappingURL=manager.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/manager.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/ordering.js":
/*!********************************************************!*\
  !*** ./node_modules/brackets-manager/dist/ordering.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n// https://web.archive.org/web/20200601102344/https://tl.net/forum/sc2-tournaments/202139-superior-double-elimination-losers-bracket-seeding\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultMinorOrdering = exports.ordering = void 0;\nexports.ordering = {\n    'natural': (array) => [...array],\n    'reverse': (array) => [...array].reverse(),\n    'half_shift': (array) => [...array.slice(array.length / 2), ...array.slice(0, array.length / 2)],\n    'reverse_half_shift': (array) => [...array.slice(0, array.length / 2).reverse(), ...array.slice(array.length / 2).reverse()],\n    'pair_flip': (array) => {\n        const result = [];\n        for (let i = 0; i < array.length; i += 2)\n            result.push(array[i + 1], array[i]);\n        return result;\n    },\n    'inner_outer': (array) => {\n        if (array.length === 2)\n            return array;\n        const size = array.length / 4;\n        const innerPart = [array.slice(size, 2 * size), array.slice(2 * size, 3 * size)]; // [_, X, X, _]\n        const outerPart = [array.slice(0, size), array.slice(3 * size, 4 * size)]; // [X, _, _, X]\n        const methods = {\n            inner(part) {\n                return [part[0].pop(), part[1].shift()];\n            },\n            outer(part) {\n                return [part[0].shift(), part[1].pop()];\n            },\n        };\n        const result = [];\n        /**\n         * Adds a part (inner or outer) of a part.\n         *\n         * @param part The part to process.\n         * @param method The method to use.\n         */\n        function add(part, method) {\n            if (part[0].length > 0 && part[1].length > 0)\n                result.push(...methods[method](part));\n        }\n        for (let i = 0; i < size / 2; i++) {\n            add(outerPart, 'outer'); // Outer part's outer\n            add(innerPart, 'inner'); // Inner part's inner\n            add(outerPart, 'inner'); // Outer part's inner\n            add(innerPart, 'outer'); // Inner part's outer\n        }\n        return result;\n    },\n    'groups.effort_balanced': (array, groupCount) => {\n        const result = [];\n        let i = 0, j = 0;\n        while (result.length < array.length) {\n            result.push(array[i]);\n            i += groupCount;\n            if (i >= array.length)\n                i = ++j;\n        }\n        return result;\n    },\n    'groups.seed_optimized': (array, groupCount) => {\n        const groups = Array.from(Array(groupCount), (_) => []);\n        for (let run = 0; run < array.length / groupCount; run++) {\n            if (run % 2 === 0) {\n                for (let group = 0; group < groupCount; group++)\n                    groups[group].push(array[run * groupCount + group]);\n            }\n            else {\n                for (let group = 0; group < groupCount; group++)\n                    groups[groupCount - group - 1].push(array[run * groupCount + group]);\n            }\n        }\n        return groups.flat();\n    },\n    'groups.bracket_optimized': () => {\n        throw Error('Not implemented.');\n    },\n};\nexports.defaultMinorOrdering = {\n    // 1 or 2: Not possible.\n    4: ['natural', 'reverse'],\n    8: ['natural', 'reverse', 'natural'],\n    16: ['natural', 'reverse_half_shift', 'reverse', 'natural'],\n    32: ['natural', 'reverse', 'half_shift', 'natural', 'natural'],\n    64: ['natural', 'reverse', 'half_shift', 'reverse', 'natural', 'natural'],\n    128: ['natural', 'reverse', 'half_shift', 'pair_flip', 'pair_flip', 'pair_flip', 'natural'],\n};\n//# sourceMappingURL=ordering.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/ordering.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/reset.js":
/*!*****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/reset.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Reset = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst updater_1 = __webpack_require__(/*! ./base/updater */ \"./node_modules/brackets-manager/dist/base/updater.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Reset extends updater_1.BaseUpdater {\n    /**\n     * Resets the results of a match.\n     *\n     * This will update related matches accordingly.\n     *\n     * @param matchId ID of the match.\n     */\n    async matchResults(matchId) {\n        const stored = await this.storage.select('match', matchId);\n        if (!stored)\n            throw Error('Match not found.');\n        // The user can handle forfeits with matches which have child games in two possible ways:\n        //\n        // 1. Set forfeits for the parent match directly.\n        //    --> The child games will never be updated: not locked, not finished, without forfeit. They will just be ignored and never be played.\n        //    --> To reset the forfeits, the user has to reset the parent match, with `reset.matchResults()`.\n        //    --> `reset.matchResults()` will be usable **only** to reset the forfeit of the parent match. Otherwise it will throw the error below.\n        //\n        // 2. Set forfeits for each child game.\n        //    --> The parent match won't automatically have a forfeit, but will be updated with a computed score according to the forfeited match games.\n        //    --> To reset the forfeits, the user has to reset each child game on its own, with `reset.matchGameResults()`.\n        //    --> `reset.matchResults()` will throw the error below in all cases.\n        if (!helpers.isMatchForfeitCompleted(stored) && stored.child_count > 0)\n            throw Error('The parent match is controlled by its child games and its result cannot be reset.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', stored.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(stored.round_id);\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        const nextMatches = await this.getNextMatches(stored, matchLocation, stage, roundNumber, roundCount);\n        if (nextMatches.some(match => match && match.status >= brackets_model_1.Status.Running && !helpers.isMatchByeCompleted(match)))\n            throw Error('The match is locked.');\n        helpers.resetMatchResults(stored);\n        await this.applyMatchUpdate(stored);\n        if (!helpers.isRoundRobin(stage))\n            await this.updateRelatedMatches(stored, true, true);\n    }\n    /**\n     * Resets the results of a match game.\n     *\n     * @param gameId ID of the match game.\n     */\n    async matchGameResults(gameId) {\n        const stored = await this.storage.select('match_game', gameId);\n        if (!stored)\n            throw Error('Match game not found.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const inRoundRobin = helpers.isRoundRobin(stage);\n        helpers.resetMatchResults(stored);\n        if (!await this.storage.update('match_game', stored.id, stored))\n            throw Error('Could not update the match game.');\n        await this.updateParentMatch(stored.parent_id, inRoundRobin);\n    }\n    /**\n     * Resets the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async seeding(stageId) {\n        await this.updateSeeding(stageId, null);\n    }\n}\nexports.Reset = Reset;\n//# sourceMappingURL=reset.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/reset.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/update.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/update.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Update = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst updater_1 = __webpack_require__(/*! ./base/updater */ \"./node_modules/brackets-manager/dist/base/updater.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Update extends updater_1.BaseUpdater {\n    /**\n     * Updates partial information of a match. Its id must be given.\n     *\n     * This will update related matches accordingly.\n     *\n     * @param match Values to change in a match.\n     */\n    async match(match) {\n        if (match.id === undefined)\n            throw Error('No match id given.');\n        const stored = await this.storage.select('match', match.id);\n        if (!stored)\n            throw Error('Match not found.');\n        await this.updateMatch(stored, match);\n    }\n    /**\n     * Updates partial information of a match game. Its id must be given.\n     *\n     * This will update the parent match accordingly.\n     *\n     * @param game Values to change in a match game.\n     */\n    async matchGame(game) {\n        const stored = await this.findMatchGame(game);\n        await this.updateMatchGame(stored, game);\n    }\n    /**\n     * Updates the seed ordering of every ordered round in a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seedOrdering A list of ordering methods.\n     */\n    async ordering(stageId, seedOrdering) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        helpers.ensureNotRoundRobin(stage);\n        const roundsToOrder = await this.getOrderedRounds(stage);\n        if (seedOrdering.length !== roundsToOrder.length)\n            throw Error('The count of seed orderings is incorrect.');\n        for (let i = 0; i < roundsToOrder.length; i++)\n            await this.updateRoundOrdering(roundsToOrder[i], seedOrdering[i]);\n    }\n    /**\n     * Updates the seed ordering of a round.\n     *\n     * @param roundId ID of the round.\n     * @param method Seed ordering method.\n     */\n    async roundOrdering(roundId, method) {\n        const round = await this.storage.select('round', roundId);\n        if (!round)\n            throw Error('This round does not exist.');\n        const stage = await this.storage.select('stage', round.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        helpers.ensureNotRoundRobin(stage);\n        await this.updateRoundOrdering(round, method);\n    }\n    /**\n     * Updates child count of all matches of a given level.\n     *\n     * @param level The level at which to act.\n     * @param id ID of the chosen level.\n     * @param childCount The target child count.\n     */\n    async matchChildCount(level, id, childCount) {\n        switch (level) {\n            case 'stage':\n                await this.updateStageMatchChildCount(id, childCount);\n                break;\n            case 'group':\n                await this.updateGroupMatchChildCount(id, childCount);\n                break;\n            case 'round':\n                await this.updateRoundMatchChildCount(id, childCount);\n                break;\n            case 'match':\n                const match = await this.storage.select('match', id);\n                if (!match)\n                    throw Error('Match not found.');\n                await this.adjustMatchChildGames(match, childCount);\n                break;\n            default:\n                throw Error('Unknown child count level.');\n        }\n    }\n    /**\n     * Updates the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seeding The new seeding.\n     */\n    async seeding(stageId, seeding) {\n        await this.updateSeeding(stageId, seeding);\n    }\n    /**\n     * Confirms the seeding of a stage.\n     *\n     * This will convert TBDs to BYEs and propagate them.\n     *\n     * @param stageId ID of the stage.\n     */\n    async confirmSeeding(stageId) {\n        await this.confirmCurrentSeeding(stageId);\n    }\n    /**\n     * Update the seed ordering of a round.\n     *\n     * @param round The round of which to update the ordering.\n     * @param method The new ordering method.\n     */\n    async updateRoundOrdering(round, method) {\n        const matches = await this.storage.select('match', { round_id: round.id });\n        if (!matches)\n            throw Error('This round has no match.');\n        if (matches.some(match => match.status > brackets_model_1.Status.Ready))\n            throw Error('At least one match has started or is completed.');\n        const stage = await this.storage.select('stage', round.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        if (stage.settings.size === undefined)\n            throw Error('Undefined stage size.');\n        const group = await this.storage.select('group', round.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const inLoserBracket = helpers.isLoserBracket(stage.type, group.number);\n        const roundCountLB = helpers.getLowerBracketRoundCount(stage.settings.size);\n        const seeds = helpers.getSeeds(inLoserBracket, round.number, roundCountLB, matches.length);\n        const positions = ordering_1.ordering[method](seeds);\n        await this.applyRoundOrdering(round.number, matches, positions);\n    }\n    /**\n     * Updates child count of all matches of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param childCount The target child count.\n     */\n    async updateStageMatchChildCount(stageId, childCount) {\n        if (!await this.storage.update('match', { stage_id: stageId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { stage_id: stageId });\n        if (!matches)\n            throw Error('This stage has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates child count of all matches of a group.\n     *\n     * @param groupId ID of the group.\n     * @param childCount The target child count.\n     */\n    async updateGroupMatchChildCount(groupId, childCount) {\n        if (!await this.storage.update('match', { group_id: groupId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { group_id: groupId });\n        if (!matches)\n            throw Error('This group has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates child count of all matches of a round.\n     *\n     * @param roundId ID of the round.\n     * @param childCount The target child count.\n     */\n    async updateRoundMatchChildCount(roundId, childCount) {\n        if (!await this.storage.update('match', { round_id: roundId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { round_id: roundId });\n        if (!matches)\n            throw Error('This round has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates the ordering of participants in a round's matches.\n     *\n     * @param roundNumber The number of the round.\n     * @param matches The matches of the round.\n     * @param positions The new positions.\n     */\n    async applyRoundOrdering(roundNumber, matches, positions) {\n        for (const match of matches) {\n            const updated = { ...match };\n            updated.opponent1 = helpers.findPosition(matches, positions.shift());\n            // The only rounds where we have a second ordered participant are first rounds of brackets (upper and lower).\n            if (roundNumber === 1)\n                updated.opponent2 = helpers.findPosition(matches, positions.shift());\n            if (!await this.storage.update('match', updated.id, updated))\n                throw Error('Could not update the match.');\n        }\n    }\n    /**\n     * Adds or deletes match games of a match based on a target child count.\n     *\n     * @param match The match of which child games need to be adjusted.\n     * @param targetChildCount The target child count.\n     */\n    async adjustMatchChildGames(match, targetChildCount) {\n        const games = await this.storage.select('match_game', { parent_id: match.id });\n        let childCount = games ? games.length : 0;\n        while (childCount < targetChildCount) {\n            const id = await this.storage.insert('match_game', {\n                number: childCount + 1,\n                stage_id: match.stage_id,\n                parent_id: match.id,\n                status: match.status,\n                opponent1: { id: null },\n                opponent2: { id: null },\n            });\n            if (id === -1)\n                throw Error('Could not adjust the match games when inserting.');\n            childCount++;\n        }\n        while (childCount > targetChildCount) {\n            const deleted = await this.storage.delete('match_game', {\n                parent_id: match.id,\n                number: childCount,\n            });\n            if (!deleted)\n                throw Error('Could not adjust the match games when deleting.');\n            childCount--;\n        }\n        if (!await this.storage.update('match', match.id, { ...match, child_count: targetChildCount }))\n            throw Error('Could not update the match.');\n    }\n}\nexports.Update = Update;\n//# sourceMappingURL=update.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/update.js?");

/***/ }),

/***/ "./node_modules/brackets-memory-db/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/brackets-memory-db/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryDatabase = void 0;\nconst rfdc = __webpack_require__(/*! rfdc */ \"./node_modules/rfdc/index.js\");\nconst clone = rfdc();\nclass InMemoryDatabase {\n    data = {\n        participant: [],\n        stage: [],\n        group: [],\n        round: [],\n        match: [],\n        match_game: [],\n    };\n    /**\n     * @param data \"import\" data from external\n     */\n    setData(data) {\n        this.data = data;\n    }\n    /**\n     * @param partial Filter\n     */\n    makeFilter(partial) {\n        return (entry) => {\n            let result = true;\n            for (const key of Object.keys(partial))\n                result = result && entry[key] === partial[key];\n            return result;\n        };\n    }\n    /**\n     * Clearing all of the data\n     */\n    reset() {\n        this.data = {\n            participant: [],\n            stage: [],\n            group: [],\n            round: [],\n            match: [],\n            match_game: [],\n        };\n    }\n    /**\n     * Implementation of insert\n     *\n     * @param table Where to insert.\n     * @param values What to insert.\n     */\n    insert(table, values) {\n        let id = this.data[table].length > 0\n            ? (Math.max(...this.data[table].map(d => d.id)) + 1)\n            : 0;\n        if (!Array.isArray(values)) {\n            try {\n                // @ts-ignore\n                this.data[table].push({ id, ...values });\n            }\n            catch (error) {\n                return new Promise((resolve) => {\n                    resolve(-1);\n                });\n            }\n            return new Promise((resolve) => {\n                resolve(id);\n            });\n        }\n        try {\n            values.map((object) => {\n                // @ts-ignore\n                this.data[table].push({ id: id++, ...object });\n            });\n        }\n        catch (error) {\n            return new Promise((resolve) => {\n                resolve(false);\n            });\n        }\n        return new Promise((resolve) => {\n            resolve(true);\n        });\n    }\n    /**\n     * @param table Where to get from.\n     * @param arg Arg.\n     */\n    select(table, arg) {\n        try {\n            if (arg === undefined) {\n                return new Promise((resolve) => {\n                    // @ts-ignore\n                    resolve(this.data[table].map(clone));\n                });\n            }\n            if (typeof arg === 'number') {\n                return new Promise((resolve) => {\n                    // @ts-ignore\n                    resolve(clone(this.data[table].find(d => d.id === arg)));\n                });\n            }\n            return new Promise((resolve) => {\n                // @ts-ignore\n                resolve(this.data[table].filter(this.makeFilter(arg)).map(clone));\n            });\n        }\n        catch (error) {\n            return new Promise((resolve) => {\n                resolve(null);\n            });\n        }\n    }\n    /**\n     * Updates data in a table.\n     *\n     * @param table Where to update.\n     * @param arg\n     * @param value How to update.\n     */\n    update(table, arg, value) {\n        if (typeof arg === 'number') {\n            try {\n                // @ts-ignore\n                this.data[table][arg] = value;\n                return new Promise((resolve) => {\n                    resolve(true);\n                });\n            }\n            catch (error) {\n                return new Promise((resolve) => {\n                    resolve(false);\n                });\n            }\n        }\n        // @ts-ignore\n        const values = this.data[table].filter(this.makeFilter(arg));\n        if (!values) {\n            return new Promise((resolve) => {\n                resolve(false);\n            });\n        }\n        values.forEach((v) => {\n            const existing = this.data[table][v.id];\n            for (const key in value) {\n                // @ts-ignore\n                if (existing[key] && typeof existing[key] === 'object' && typeof value[key] === 'object') {\n                    // @ts-ignore\n                    Object.assign(existing[key], value[key]); // For opponent objects, this does a deep merge of level 2.\n                }\n                else {\n                    // @ts-ignore\n                    existing[key] = value[key]; // Otherwise, do a simple value assignment.\n                }\n            }\n            this.data[table][v.id] = existing;\n        });\n        return new Promise((resolve) => {\n            resolve(true);\n        });\n    }\n    /**\n     * Delete data in a table, based on a filter.\n     *\n     * @param table Where to delete in.\n     * @param filter An object to filter data.\n     */\n    delete(table, filter) {\n        const values = this.data[table];\n        if (!values) {\n            return new Promise((resolve) => {\n                resolve(false);\n            });\n        }\n        if (!filter) {\n            this.data[table] = [];\n            return new Promise((resolve) => {\n                resolve(true);\n            });\n        }\n        const predicate = this.makeFilter(filter);\n        const negativeFilter = (value) => !predicate(value);\n        // @ts-ignore\n        this.data[table] = values.filter(negativeFilter);\n        return new Promise((resolve) => {\n            resolve(true);\n        });\n    }\n}\nexports.InMemoryDatabase = InMemoryDatabase;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-memory-db/dist/index.js?");

/***/ }),

/***/ "./node_modules/brackets-model/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-model/dist/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Status = void 0;\nconst other_1 = __webpack_require__(/*! ./other */ \"./node_modules/brackets-model/dist/other.js\");\nObject.defineProperty(exports, \"Status\", ({ enumerable: true, get: function () { return other_1.Status; } }));\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-model/dist/index.js?");

/***/ }),

/***/ "./node_modules/brackets-model/dist/other.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-model/dist/other.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n/*---------------------------------------------------------------------------|\n * Contains the rest of the types which doesn't belong to the other files.\n *--------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Status = void 0;\n/**\n * The possible status for a match.\n */\nvar Status;\n(function (Status) {\n    /** The two matches leading to this one are not completed yet. */\n    Status[Status[\"Locked\"] = 0] = \"Locked\";\n    /** One participant is ready and waiting for the other one. */\n    Status[Status[\"Waiting\"] = 1] = \"Waiting\";\n    /** Both participants are ready to start. */\n    Status[Status[\"Ready\"] = 2] = \"Ready\";\n    /** The match is running. */\n    Status[Status[\"Running\"] = 3] = \"Running\";\n    /** The match is completed. */\n    Status[Status[\"Completed\"] = 4] = \"Completed\";\n    /** At least one participant completed his following match. */\n    Status[Status[\"Archived\"] = 5] = \"Archived\";\n})(Status = exports.Status || (exports.Status = {}));\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-model/dist/other.js?");

/***/ }),

/***/ "./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Browser; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n\n\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\nfunction defaults(obj) {\n  each.call(slice.call(arguments, 1), function (source) {\n    if (source) {\n      for (var prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\n\n// eslint-disable-next-line no-control-regex\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nvar serializeCookie = function serializeCookie(name, val, options) {\n  var opt = options || {};\n  opt.path = opt.path || '/';\n  var value = encodeURIComponent(val);\n  var str = name + '=' + value;\n\n  if (opt.maxAge > 0) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) str += '; HttpOnly';\n  if (opt.secure) str += '; Secure';\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n\n      case 'none':\n        str += '; SameSite=None';\n        break;\n\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n};\n\nvar cookie = {\n  create: function create(name, value, minutes, domain) {\n    var cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      path: '/',\n      sameSite: 'strict'\n    };\n\n    if (minutes) {\n      cookieOptions.expires = new Date();\n      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n    }\n\n    if (domain) cookieOptions.domain = domain;\n    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);\n  },\n  read: function read(name) {\n    var nameEQ = name + '=';\n    var ca = document.cookie.split(';');\n\n    for (var i = 0; i < ca.length; i++) {\n      var c = ca[i];\n\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1, c.length);\n      }\n\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n\n    return null;\n  },\n  remove: function remove(name) {\n    this.create(name, '', -1);\n  }\n};\nvar cookie$1 = {\n  name: 'cookie',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupCookie && typeof document !== 'undefined') {\n      var c = cookie.read(options.lookupCookie);\n      if (c) found = c;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupCookie && typeof document !== 'undefined') {\n      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);\n    }\n  }\n};\n\nvar querystring = {\n  name: 'querystring',\n  lookup: function lookup(options) {\n    var found;\n\n    if (typeof window !== 'undefined') {\n      var search = window.location.search;\n\n      if (!window.location.search && window.location.hash && window.location.hash.indexOf('?') > -1) {\n        search = window.location.hash.substring(window.location.hash.indexOf('?'));\n      }\n\n      var query = search.substring(1);\n      var params = query.split('&');\n\n      for (var i = 0; i < params.length; i++) {\n        var pos = params[i].indexOf('=');\n\n        if (pos > 0) {\n          var key = params[i].substring(0, pos);\n\n          if (key === options.lookupQuerystring) {\n            found = params[i].substring(pos + 1);\n          }\n        }\n      }\n    }\n\n    return found;\n  }\n};\n\nvar hasLocalStorageSupport = null;\n\nvar localStorageAvailable = function localStorageAvailable() {\n  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n\n  try {\n    hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;\n    var testKey = 'i18next.translate.boo';\n    window.localStorage.setItem(testKey, 'foo');\n    window.localStorage.removeItem(testKey);\n  } catch (e) {\n    hasLocalStorageSupport = false;\n  }\n\n  return hasLocalStorageSupport;\n};\n\nvar localStorage = {\n  name: 'localStorage',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupLocalStorage && localStorageAvailable()) {\n      var lng = window.localStorage.getItem(options.lookupLocalStorage);\n      if (lng) found = lng;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupLocalStorage && localStorageAvailable()) {\n      window.localStorage.setItem(options.lookupLocalStorage, lng);\n    }\n  }\n};\n\nvar hasSessionStorageSupport = null;\n\nvar sessionStorageAvailable = function sessionStorageAvailable() {\n  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n\n  try {\n    hasSessionStorageSupport = window !== 'undefined' && window.sessionStorage !== null;\n    var testKey = 'i18next.translate.boo';\n    window.sessionStorage.setItem(testKey, 'foo');\n    window.sessionStorage.removeItem(testKey);\n  } catch (e) {\n    hasSessionStorageSupport = false;\n  }\n\n  return hasSessionStorageSupport;\n};\n\nvar sessionStorage = {\n  name: 'sessionStorage',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupSessionStorage && sessionStorageAvailable()) {\n      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);\n      if (lng) found = lng;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupSessionStorage && sessionStorageAvailable()) {\n      window.sessionStorage.setItem(options.lookupSessionStorage, lng);\n    }\n  }\n};\n\nvar navigator$1 = {\n  name: 'navigator',\n  lookup: function lookup(options) {\n    var found = [];\n\n    if (typeof navigator !== 'undefined') {\n      if (navigator.languages) {\n        // chrome only; not an array, so can't use .push.apply instead of iterating\n        for (var i = 0; i < navigator.languages.length; i++) {\n          found.push(navigator.languages[i]);\n        }\n      }\n\n      if (navigator.userLanguage) {\n        found.push(navigator.userLanguage);\n      }\n\n      if (navigator.language) {\n        found.push(navigator.language);\n      }\n    }\n\n    return found.length > 0 ? found : undefined;\n  }\n};\n\nvar htmlTag = {\n  name: 'htmlTag',\n  lookup: function lookup(options) {\n    var found;\n    var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);\n\n    if (htmlTag && typeof htmlTag.getAttribute === 'function') {\n      found = htmlTag.getAttribute('lang');\n    }\n\n    return found;\n  }\n};\n\nvar path = {\n  name: 'path',\n  lookup: function lookup(options) {\n    var found;\n\n    if (typeof window !== 'undefined') {\n      var language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n\n      if (language instanceof Array) {\n        if (typeof options.lookupFromPathIndex === 'number') {\n          if (typeof language[options.lookupFromPathIndex] !== 'string') {\n            return undefined;\n          }\n\n          found = language[options.lookupFromPathIndex].replace('/', '');\n        } else {\n          found = language[0].replace('/', '');\n        }\n      }\n    }\n\n    return found;\n  }\n};\n\nvar subdomain = {\n  name: 'subdomain',\n  lookup: function lookup(options) {\n    var found;\n\n    if (typeof window !== 'undefined') {\n      var language = window.location.href.match(/(?:http[s]*\\:\\/\\/)*(.*?)\\.(?=[^\\/]*\\..{2,5})/gi);\n\n      if (language instanceof Array) {\n        if (typeof options.lookupFromSubdomainIndex === 'number') {\n          found = language[options.lookupFromSubdomainIndex].replace('http://', '').replace('https://', '').replace('.', '');\n        } else {\n          found = language[0].replace('http://', '').replace('https://', '').replace('.', '');\n        }\n      }\n    }\n\n    return found;\n  }\n};\n\nfunction getDefaults() {\n  return {\n    order: ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'],\n    lookupQuerystring: 'lng',\n    lookupCookie: 'i18next',\n    lookupLocalStorage: 'i18nextLng',\n    lookupSessionStorage: 'i18nextLng',\n    // cache user language\n    caches: ['localStorage'],\n    excludeCacheFor: ['cimode'] //cookieMinutes: 10,\n    //cookieDomain: 'myDomain'\n\n  };\n}\n\nvar Browser = /*#__PURE__*/function () {\n  function Browser(services) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Browser);\n\n    this.type = 'languageDetector';\n    this.detectors = {};\n    this.init(services, options);\n  }\n\n  (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Browser, [{\n    key: \"init\",\n    value: function init(services) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.services = services;\n      this.options = defaults(options, this.options || {}, getDefaults()); // backwards compatibility\n\n      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n      this.i18nOptions = i18nOptions;\n      this.addDetector(cookie$1);\n      this.addDetector(querystring);\n      this.addDetector(localStorage);\n      this.addDetector(sessionStorage);\n      this.addDetector(navigator$1);\n      this.addDetector(htmlTag);\n      this.addDetector(path);\n      this.addDetector(subdomain);\n    }\n  }, {\n    key: \"addDetector\",\n    value: function addDetector(detector) {\n      this.detectors[detector.name] = detector;\n    }\n  }, {\n    key: \"detect\",\n    value: function detect(detectionOrder) {\n      var _this = this;\n\n      if (!detectionOrder) detectionOrder = this.options.order;\n      var detected = [];\n      detectionOrder.forEach(function (detectorName) {\n        if (_this.detectors[detectorName]) {\n          var lookup = _this.detectors[detectorName].lookup(_this.options);\n\n          if (lookup && typeof lookup === 'string') lookup = [lookup];\n          if (lookup) detected = detected.concat(lookup);\n        }\n      });\n      if (this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n\n      return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n    }\n  }, {\n    key: \"cacheUserLanguage\",\n    value: function cacheUserLanguage(lng, caches) {\n      var _this2 = this;\n\n      if (!caches) caches = this.options.caches;\n      if (!caches) return;\n      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n      caches.forEach(function (cacheName) {\n        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);\n      });\n    }\n  }]);\n\n  return Browser;\n}();\n\nBrowser.type = 'languageDetector';\n\n\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js?");

/***/ }),

/***/ "./node_modules/i18next/dist/cjs/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/cjs/i18next.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\nvar _assertThisInitialized = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\nvar _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\");\nvar _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\nvar _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\nvar _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\");\nvar _toArray = __webpack_require__(/*! @babel/runtime/helpers/toArray */ \"./node_modules/@babel/runtime/helpers/toArray.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);\nvar _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\nvar _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\nvar _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);\nvar _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);\nvar _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);\nvar _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);\nvar _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);\nvar _toArray__default = /*#__PURE__*/_interopDefaultLegacy(_toArray);\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar consoleLogger = {\n  type: 'logger',\n  log: function log(args) {\n    this.output('log', args);\n  },\n  warn: function warn(args) {\n    this.output('warn', args);\n  },\n  error: function error(args) {\n    this.output('error', args);\n  },\n  output: function output(type, args) {\n    if (console && console[type]) console[type].apply(console, args);\n  }\n};\n\nvar Logger = function () {\n  function Logger(concreteLogger) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck__default['default'](this, Logger);\n\n    this.init(concreteLogger, options);\n  }\n\n  _createClass__default['default'](Logger, [{\n    key: \"init\",\n    value: function init(concreteLogger) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.prefix = options.prefix || 'i18next:';\n      this.logger = concreteLogger || consoleLogger;\n      this.options = options;\n      this.debug = options.debug;\n    }\n  }, {\n    key: \"setDebug\",\n    value: function setDebug(bool) {\n      this.debug = bool;\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.forward(args, 'log', '', true);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.forward(args, 'warn', '', true);\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.forward(args, 'error', '');\n    }\n  }, {\n    key: \"deprecate\",\n    value: function deprecate() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(args, lvl, prefix, debugOnly) {\n      if (debugOnly && !this.debug) return null;\n      if (typeof args[0] === 'string') args[0] = \"\".concat(prefix).concat(this.prefix, \" \").concat(args[0]);\n      return this.logger[lvl](args);\n    }\n  }, {\n    key: \"create\",\n    value: function create(moduleName) {\n      return new Logger(this.logger, _objectSpread(_objectSpread({}, {\n        prefix: \"\".concat(this.prefix, \":\").concat(moduleName, \":\")\n      }), this.options));\n    }\n  }]);\n\n  return Logger;\n}();\n\nvar baseLogger = new Logger();\n\nvar EventEmitter = function () {\n  function EventEmitter() {\n    _classCallCheck__default['default'](this, EventEmitter);\n\n    this.observers = {};\n  }\n\n  _createClass__default['default'](EventEmitter, [{\n    key: \"on\",\n    value: function on(events, listener) {\n      var _this = this;\n\n      events.split(' ').forEach(function (event) {\n        _this.observers[event] = _this.observers[event] || [];\n\n        _this.observers[event].push(listener);\n      });\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      if (!this.observers[event]) return;\n\n      if (!listener) {\n        delete this.observers[event];\n        return;\n      }\n\n      this.observers[event] = this.observers[event].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (this.observers[event]) {\n        var cloned = [].concat(this.observers[event]);\n        cloned.forEach(function (observer) {\n          observer.apply(void 0, args);\n        });\n      }\n\n      if (this.observers['*']) {\n        var _cloned = [].concat(this.observers['*']);\n\n        _cloned.forEach(function (observer) {\n          observer.apply(observer, [event].concat(args));\n        });\n      }\n    }\n  }]);\n\n  return EventEmitter;\n}();\n\nfunction defer() {\n  var res;\n  var rej;\n  var promise = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n}\nfunction makeString(object) {\n  if (object == null) return '';\n  return '' + object;\n}\nfunction copy(a, s, t) {\n  a.forEach(function (m) {\n    if (s[m]) t[m] = s[m];\n  });\n}\n\nfunction getLastOfPath(object, path, Empty) {\n  function cleanKey(key) {\n    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;\n  }\n\n  function canNotTraverseDeeper() {\n    return !object || typeof object === 'string';\n  }\n\n  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');\n\n  while (stack.length > 1) {\n    if (canNotTraverseDeeper()) return {};\n    var key = cleanKey(stack.shift());\n    if (!object[key] && Empty) object[key] = new Empty();\n\n    if (Object.prototype.hasOwnProperty.call(object, key)) {\n      object = object[key];\n    } else {\n      object = {};\n    }\n  }\n\n  if (canNotTraverseDeeper()) return {};\n  return {\n    obj: object,\n    k: cleanKey(stack.shift())\n  };\n}\n\nfunction setPath(object, path, newValue) {\n  var _getLastOfPath = getLastOfPath(object, path, Object),\n      obj = _getLastOfPath.obj,\n      k = _getLastOfPath.k;\n\n  obj[k] = newValue;\n}\nfunction pushPath(object, path, newValue, concat) {\n  var _getLastOfPath2 = getLastOfPath(object, path, Object),\n      obj = _getLastOfPath2.obj,\n      k = _getLastOfPath2.k;\n\n  obj[k] = obj[k] || [];\n  if (concat) obj[k] = obj[k].concat(newValue);\n  if (!concat) obj[k].push(newValue);\n}\nfunction getPath(object, path) {\n  var _getLastOfPath3 = getLastOfPath(object, path),\n      obj = _getLastOfPath3.obj,\n      k = _getLastOfPath3.k;\n\n  if (!obj) return undefined;\n  return obj[k];\n}\nfunction getPathWithDefaults(data, defaultData, key) {\n  var value = getPath(data, key);\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return getPath(defaultData, key);\n}\nfunction deepExtend(target, source, overwrite) {\n  for (var prop in source) {\n    if (prop !== '__proto__' && prop !== 'constructor') {\n      if (prop in target) {\n        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {\n          if (overwrite) target[prop] = source[prop];\n        } else {\n          deepExtend(target[prop], source[prop], overwrite);\n        }\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\nfunction regexEscape(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nvar _entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;'\n};\nfunction escape(data) {\n  if (typeof data === 'string') {\n    return data.replace(/[&<>\"'\\/]/g, function (s) {\n      return _entityMap[s];\n    });\n  }\n\n  return data;\n}\nvar isIE10 = typeof window !== 'undefined' && window.navigator && typeof window.navigator.userAgentData === 'undefined' && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;\nvar chars = [' ', ',', '?', '!', ';'];\nfunction looksLikeObjectPath(key, nsSeparator, keySeparator) {\n  nsSeparator = nsSeparator || '';\n  keySeparator = keySeparator || '';\n  var possibleChars = chars.filter(function (c) {\n    return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;\n  });\n  if (possibleChars.length === 0) return true;\n  var r = new RegExp(\"(\".concat(possibleChars.map(function (c) {\n    return c === '?' ? '\\\\?' : c;\n  }).join('|'), \")\"));\n  var matched = !r.test(key);\n\n  if (!matched) {\n    var ki = key.indexOf(keySeparator);\n\n    if (ki > 0 && !r.test(key.substring(0, ki))) {\n      matched = true;\n    }\n  }\n\n  return matched;\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction deepFind(obj, path) {\n  var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n  if (!obj) return undefined;\n  if (obj[path]) return obj[path];\n  var paths = path.split(keySeparator);\n  var current = obj;\n\n  for (var i = 0; i < paths.length; ++i) {\n    if (!current) return undefined;\n\n    if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {\n      return undefined;\n    }\n\n    if (current[paths[i]] === undefined) {\n      var j = 2;\n      var p = paths.slice(i, i + j).join(keySeparator);\n      var mix = current[p];\n\n      while (mix === undefined && paths.length > i + j) {\n        j++;\n        p = paths.slice(i, i + j).join(keySeparator);\n        mix = current[p];\n      }\n\n      if (mix === undefined) return undefined;\n      if (mix === null) return null;\n\n      if (path.endsWith(p)) {\n        if (typeof mix === 'string') return mix;\n        if (p && typeof mix[p] === 'string') return mix[p];\n      }\n\n      var joinedPath = paths.slice(i + j).join(keySeparator);\n      if (joinedPath) return deepFind(mix, joinedPath, keySeparator);\n      return undefined;\n    }\n\n    current = current[paths[i]];\n  }\n\n  return current;\n}\n\nvar ResourceStore = function (_EventEmitter) {\n  _inherits__default['default'](ResourceStore, _EventEmitter);\n\n  var _super = _createSuper(ResourceStore);\n\n  function ResourceStore(data) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      ns: ['translation'],\n      defaultNS: 'translation'\n    };\n\n    _classCallCheck__default['default'](this, ResourceStore);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized__default['default'](_this));\n    }\n\n    _this.data = data || {};\n    _this.options = options;\n\n    if (_this.options.keySeparator === undefined) {\n      _this.options.keySeparator = '.';\n    }\n\n    if (_this.options.ignoreJSONStructure === undefined) {\n      _this.options.ignoreJSONStructure = true;\n    }\n\n    return _this;\n  }\n\n  _createClass__default['default'](ResourceStore, [{\n    key: \"addNamespaces\",\n    value: function addNamespaces(ns) {\n      if (this.options.ns.indexOf(ns) < 0) {\n        this.options.ns.push(ns);\n      }\n    }\n  }, {\n    key: \"removeNamespaces\",\n    value: function removeNamespaces(ns) {\n      var index = this.options.ns.indexOf(ns);\n\n      if (index > -1) {\n        this.options.ns.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"getResource\",\n    value: function getResource(lng, ns, key) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n      var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n      var path = [lng, ns];\n      if (key && typeof key !== 'string') path = path.concat(key);\n      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n      }\n\n      var result = getPath(this.data, path);\n      if (result || !ignoreJSONStructure || typeof key !== 'string') return result;\n      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n  }, {\n    key: \"addResource\",\n    value: function addResource(lng, ns, key, value) {\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n        silent: false\n      };\n      var keySeparator = this.options.keySeparator;\n      if (keySeparator === undefined) keySeparator = '.';\n      var path = [lng, ns];\n      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n        value = ns;\n        ns = path[1];\n      }\n\n      this.addNamespaces(ns);\n      setPath(this.data, path, value);\n      if (!options.silent) this.emit('added', lng, ns, key, value);\n    }\n  }, {\n    key: \"addResources\",\n    value: function addResources(lng, ns, resources) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        silent: false\n      };\n\n      for (var m in resources) {\n        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {\n          silent: true\n        });\n      }\n\n      if (!options.silent) this.emit('added', lng, ns, resources);\n    }\n  }, {\n    key: \"addResourceBundle\",\n    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n        silent: false\n      };\n      var path = [lng, ns];\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n        deep = resources;\n        resources = ns;\n        ns = path[1];\n      }\n\n      this.addNamespaces(ns);\n      var pack = getPath(this.data, path) || {};\n\n      if (deep) {\n        deepExtend(pack, resources, overwrite);\n      } else {\n        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);\n      }\n\n      setPath(this.data, path, pack);\n      if (!options.silent) this.emit('added', lng, ns, resources);\n    }\n  }, {\n    key: \"removeResourceBundle\",\n    value: function removeResourceBundle(lng, ns) {\n      if (this.hasResourceBundle(lng, ns)) {\n        delete this.data[lng][ns];\n      }\n\n      this.removeNamespaces(ns);\n      this.emit('removed', lng, ns);\n    }\n  }, {\n    key: \"hasResourceBundle\",\n    value: function hasResourceBundle(lng, ns) {\n      return this.getResource(lng, ns) !== undefined;\n    }\n  }, {\n    key: \"getResourceBundle\",\n    value: function getResourceBundle(lng, ns) {\n      if (!ns) ns = this.options.defaultNS;\n      if (this.options.compatibilityAPI === 'v1') return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));\n      return this.getResource(lng, ns);\n    }\n  }, {\n    key: \"getDataByLanguage\",\n    value: function getDataByLanguage(lng) {\n      return this.data[lng];\n    }\n  }, {\n    key: \"hasLanguageSomeTranslations\",\n    value: function hasLanguageSomeTranslations(lng) {\n      var data = this.getDataByLanguage(lng);\n      var n = data && Object.keys(data) || [];\n      return !!n.find(function (v) {\n        return data[v] && Object.keys(data[v]).length > 0;\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.data;\n    }\n  }]);\n\n  return ResourceStore;\n}(EventEmitter);\n\nvar postProcessor = {\n  processors: {},\n  addPostProcessor: function addPostProcessor(module) {\n    this.processors[module.name] = module;\n  },\n  handle: function handle(processors, value, key, options, translator) {\n    var _this = this;\n\n    processors.forEach(function (processor) {\n      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);\n    });\n    return value;\n  }\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }\n\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar checkedLoadedFor = {};\n\nvar Translator = function (_EventEmitter) {\n  _inherits__default['default'](Translator, _EventEmitter);\n\n  var _super = _createSuper$1(Translator);\n\n  function Translator(services) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck__default['default'](this, Translator);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized__default['default'](_this));\n    }\n\n    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized__default['default'](_this));\n    _this.options = options;\n\n    if (_this.options.keySeparator === undefined) {\n      _this.options.keySeparator = '.';\n    }\n\n    _this.logger = baseLogger.create('translator');\n    return _this;\n  }\n\n  _createClass__default['default'](Translator, [{\n    key: \"changeLanguage\",\n    value: function changeLanguage(lng) {\n      if (lng) this.language = lng;\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        interpolation: {}\n      };\n\n      if (key === undefined || key === null) {\n        return false;\n      }\n\n      var resolved = this.resolve(key, options);\n      return resolved && resolved.res !== undefined;\n    }\n  }, {\n    key: \"extractFromKey\",\n    value: function extractFromKey(key, options) {\n      var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n      if (nsSeparator === undefined) nsSeparator = ':';\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n      var namespaces = options.ns || this.options.defaultNS || [];\n      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n\n      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n        var m = key.match(this.interpolator.nestingRegexp);\n\n        if (m && m.length > 0) {\n          return {\n            key: key,\n            namespaces: namespaces\n          };\n        }\n\n        var parts = key.split(nsSeparator);\n        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n        key = parts.join(keySeparator);\n      }\n\n      if (typeof namespaces === 'string') namespaces = [namespaces];\n      return {\n        key: key,\n        namespaces: namespaces\n      };\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(keys, options, lastKey) {\n      var _this2 = this;\n\n      if (_typeof__default['default'](options) !== 'object' && this.options.overloadTranslationOptionHandler) {\n        options = this.options.overloadTranslationOptionHandler(arguments);\n      }\n\n      if (!options) options = {};\n      if (keys === undefined || keys === null) return '';\n      if (!Array.isArray(keys)) keys = [String(keys)];\n      var returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n\n      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),\n          key = _this$extractFromKey.key,\n          namespaces = _this$extractFromKey.namespaces;\n\n      var namespace = namespaces[namespaces.length - 1];\n      var lng = options.lng || this.language;\n      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n\n      if (lng && lng.toLowerCase() === 'cimode') {\n        if (appendNamespaceToCIMode) {\n          var nsSeparator = options.nsSeparator || this.options.nsSeparator;\n\n          if (returnDetails) {\n            resolved.res = \"\".concat(namespace).concat(nsSeparator).concat(key);\n            return resolved;\n          }\n\n          return \"\".concat(namespace).concat(nsSeparator).concat(key);\n        }\n\n        if (returnDetails) {\n          resolved.res = key;\n          return resolved;\n        }\n\n        return key;\n      }\n\n      var resolved = this.resolve(keys, options);\n      var res = resolved && resolved.res;\n      var resUsedKey = resolved && resolved.usedKey || key;\n      var resExactUsedKey = resolved && resolved.exactUsedKey || key;\n      var resType = Object.prototype.toString.apply(res);\n      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];\n      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';\n\n      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {\n        if (!options.returnObjects && !this.options.returnObjects) {\n          if (!this.options.returnedObjectHandler) {\n            this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n          }\n\n          var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {\n            ns: namespaces\n          })) : \"key '\".concat(key, \" (\").concat(this.language, \")' returned an object instead of string.\");\n\n          if (returnDetails) {\n            resolved.res = r;\n            return resolved;\n          }\n\n          return r;\n        }\n\n        if (keySeparator) {\n          var resTypeIsArray = resType === '[object Array]';\n          var copy = resTypeIsArray ? [] : {};\n          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n\n          for (var m in res) {\n            if (Object.prototype.hasOwnProperty.call(res, m)) {\n              var deepKey = \"\".concat(newKeyToUse).concat(keySeparator).concat(m);\n              copy[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {\n                joinArrays: false,\n                ns: namespaces\n              }));\n              if (copy[m] === deepKey) copy[m] = res[m];\n            }\n          }\n\n          res = copy;\n        }\n      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {\n        res = res.join(joinArrays);\n        if (res) res = this.extendTranslation(res, keys, options, lastKey);\n      } else {\n        var usedDefault = false;\n        var usedKey = false;\n        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n        var hasDefaultValue = Translator.hasDefaultValue(options);\n        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';\n        var defaultValue = options[\"defaultValue\".concat(defaultValueSuffix)] || options.defaultValue;\n\n        if (!this.isValidLookup(res) && hasDefaultValue) {\n          usedDefault = true;\n          res = defaultValue;\n        }\n\n        if (!this.isValidLookup(res)) {\n          usedKey = true;\n          res = key;\n        }\n\n        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n\n        if (usedKey || usedDefault || updateMissing) {\n          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);\n\n          if (keySeparator) {\n            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {\n              keySeparator: false\n            }));\n            if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n          }\n\n          var lngs = [];\n          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n\n          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n            for (var i = 0; i < fallbackLngs.length; i++) {\n              lngs.push(fallbackLngs[i]);\n            }\n          } else if (this.options.saveMissingTo === 'all') {\n            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n          } else {\n            lngs.push(options.lng || this.language);\n          }\n\n          var send = function send(l, k, specificDefaultValue) {\n            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n\n            if (_this2.options.missingKeyHandler) {\n              _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {\n              _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n            }\n\n            _this2.emit('missingKey', l, namespace, k, res);\n          };\n\n          if (this.options.saveMissing) {\n            if (this.options.saveMissingPlurals && needsPluralHandling) {\n              lngs.forEach(function (language) {\n                _this2.pluralResolver.getSuffixes(language, options).forEach(function (suffix) {\n                  send([language], key + suffix, options[\"defaultValue\".concat(suffix)] || defaultValue);\n                });\n              });\n            } else {\n              send(lngs, key, defaultValue);\n            }\n          }\n        }\n\n        res = this.extendTranslation(res, keys, options, resolved, lastKey);\n        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = \"\".concat(namespace, \":\").concat(key);\n\n        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n          if (this.options.compatibilityAPI !== 'v1') {\n            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? \"\".concat(namespace, \":\").concat(key) : key, usedDefault ? res : undefined);\n          } else {\n            res = this.options.parseMissingKeyHandler(res);\n          }\n        }\n      }\n\n      if (returnDetails) {\n        resolved.res = res;\n        return resolved;\n      }\n\n      return res;\n    }\n  }, {\n    key: \"extendTranslation\",\n    value: function extendTranslation(res, key, options, resolved, lastKey) {\n      var _this3 = this;\n\n      if (this.i18nFormat && this.i18nFormat.parse) {\n        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n          resolved: resolved\n        });\n      } else if (!options.skipInterpolation) {\n        if (options.interpolation) this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {\n          interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)\n        }));\n        var skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n        var nestBef;\n\n        if (skipOnVariables) {\n          var nb = res.match(this.interpolator.nestingRegexp);\n          nestBef = nb && nb.length;\n        }\n\n        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;\n        if (this.options.interpolation.defaultVariables) data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);\n        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n\n        if (skipOnVariables) {\n          var na = res.match(this.interpolator.nestingRegexp);\n          var nestAft = na && na.length;\n          if (nestBef < nestAft) options.nest = false;\n        }\n\n        if (options.nest !== false) res = this.interpolator.nest(res, function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          if (lastKey && lastKey[0] === args[0] && !options.context) {\n            _this3.logger.warn(\"It seems you are nesting recursively key: \".concat(args[0], \" in key: \").concat(key[0]));\n\n            return null;\n          }\n\n          return _this3.translate.apply(_this3, args.concat([key]));\n        }, options);\n        if (options.interpolation) this.interpolator.reset();\n      }\n\n      var postProcess = options.postProcess || this.options.postProcess;\n      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;\n\n      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({\n          i18nResolved: resolved\n        }, options) : options, this);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(keys) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var found;\n      var usedKey;\n      var exactUsedKey;\n      var usedLng;\n      var usedNS;\n      if (typeof keys === 'string') keys = [keys];\n      keys.forEach(function (k) {\n        if (_this4.isValidLookup(found)) return;\n\n        var extracted = _this4.extractFromKey(k, options);\n\n        var key = extracted.key;\n        usedKey = key;\n        var namespaces = extracted.namespaces;\n        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);\n        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n\n        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();\n\n        var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';\n        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);\n        namespaces.forEach(function (ns) {\n          if (_this4.isValidLookup(found)) return;\n          usedNS = ns;\n\n          if (!checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {\n            checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] = true;\n\n            _this4.logger.warn(\"key \\\"\".concat(usedKey, \"\\\" for languages \\\"\").concat(codes.join(', '), \"\\\" won't get resolved as namespace \\\"\").concat(usedNS, \"\\\" was not yet loaded\"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n          }\n\n          codes.forEach(function (code) {\n            if (_this4.isValidLookup(found)) return;\n            usedLng = code;\n            var finalKeys = [key];\n\n            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {\n              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n            } else {\n              var pluralSuffix;\n              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);\n              var zeroSuffix = \"\".concat(_this4.options.pluralSeparator, \"zero\");\n\n              if (needsPluralHandling) {\n                finalKeys.push(key + pluralSuffix);\n\n                if (needsZeroSuffixLookup) {\n                  finalKeys.push(key + zeroSuffix);\n                }\n              }\n\n              if (needsContextHandling) {\n                var contextKey = \"\".concat(key).concat(_this4.options.contextSeparator).concat(options.context);\n                finalKeys.push(contextKey);\n\n                if (needsPluralHandling) {\n                  finalKeys.push(contextKey + pluralSuffix);\n\n                  if (needsZeroSuffixLookup) {\n                    finalKeys.push(contextKey + zeroSuffix);\n                  }\n                }\n              }\n            }\n\n            var possibleKey;\n\n            while (possibleKey = finalKeys.pop()) {\n              if (!_this4.isValidLookup(found)) {\n                exactUsedKey = possibleKey;\n                found = _this4.getResource(code, ns, possibleKey, options);\n              }\n            }\n          });\n        });\n      });\n      return {\n        res: found,\n        usedKey: usedKey,\n        exactUsedKey: exactUsedKey,\n        usedLng: usedLng,\n        usedNS: usedNS\n      };\n    }\n  }, {\n    key: \"isValidLookup\",\n    value: function isValidLookup(res) {\n      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n    }\n  }, {\n    key: \"getResource\",\n    value: function getResource(code, ns, key) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n      return this.resourceStore.getResource(code, ns, key, options);\n    }\n  }], [{\n    key: \"hasDefaultValue\",\n    value: function hasDefaultValue(options) {\n      var prefix = 'defaultValue';\n\n      for (var option in options) {\n        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }]);\n\n  return Translator;\n}(EventEmitter);\n\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nvar LanguageUtil = function () {\n  function LanguageUtil(options) {\n    _classCallCheck__default['default'](this, LanguageUtil);\n\n    this.options = options;\n    this.supportedLngs = this.options.supportedLngs || false;\n    this.logger = baseLogger.create('languageUtils');\n  }\n\n  _createClass__default['default'](LanguageUtil, [{\n    key: \"getScriptPartFromCode\",\n    value: function getScriptPartFromCode(code) {\n      if (!code || code.indexOf('-') < 0) return null;\n      var p = code.split('-');\n      if (p.length === 2) return null;\n      p.pop();\n      if (p[p.length - 1].toLowerCase() === 'x') return null;\n      return this.formatLanguageCode(p.join('-'));\n    }\n  }, {\n    key: \"getLanguagePartFromCode\",\n    value: function getLanguagePartFromCode(code) {\n      if (!code || code.indexOf('-') < 0) return code;\n      var p = code.split('-');\n      return this.formatLanguageCode(p[0]);\n    }\n  }, {\n    key: \"formatLanguageCode\",\n    value: function formatLanguageCode(code) {\n      if (typeof code === 'string' && code.indexOf('-') > -1) {\n        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];\n        var p = code.split('-');\n\n        if (this.options.lowerCaseLng) {\n          p = p.map(function (part) {\n            return part.toLowerCase();\n          });\n        } else if (p.length === 2) {\n          p[0] = p[0].toLowerCase();\n          p[1] = p[1].toUpperCase();\n          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n        } else if (p.length === 3) {\n          p[0] = p[0].toLowerCase();\n          if (p[1].length === 2) p[1] = p[1].toUpperCase();\n          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();\n          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n        }\n\n        return p.join('-');\n      }\n\n      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n  }, {\n    key: \"isSupportedCode\",\n    value: function isSupportedCode(code) {\n      if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {\n        code = this.getLanguagePartFromCode(code);\n      }\n\n      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n  }, {\n    key: \"getBestMatchFromCodes\",\n    value: function getBestMatchFromCodes(codes) {\n      var _this = this;\n\n      if (!codes) return null;\n      var found;\n      codes.forEach(function (code) {\n        if (found) return;\n\n        var cleanedLng = _this.formatLanguageCode(code);\n\n        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;\n      });\n\n      if (!found && this.options.supportedLngs) {\n        codes.forEach(function (code) {\n          if (found) return;\n\n          var lngOnly = _this.getLanguagePartFromCode(code);\n\n          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;\n          found = _this.options.supportedLngs.find(function (supportedLng) {\n            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;\n          });\n        });\n      }\n\n      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n      return found;\n    }\n  }, {\n    key: \"getFallbackCodes\",\n    value: function getFallbackCodes(fallbacks, code) {\n      if (!fallbacks) return [];\n      if (typeof fallbacks === 'function') fallbacks = fallbacks(code);\n      if (typeof fallbacks === 'string') fallbacks = [fallbacks];\n      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;\n      if (!code) return fallbacks[\"default\"] || [];\n      var found = fallbacks[code];\n      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n      if (!found) found = fallbacks[this.formatLanguageCode(code)];\n      if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n      if (!found) found = fallbacks[\"default\"];\n      return found || [];\n    }\n  }, {\n    key: \"toResolveHierarchy\",\n    value: function toResolveHierarchy(code, fallbackCode) {\n      var _this2 = this;\n\n      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n      var codes = [];\n\n      var addCode = function addCode(c) {\n        if (!c) return;\n\n        if (_this2.isSupportedCode(c)) {\n          codes.push(c);\n        } else {\n          _this2.logger.warn(\"rejecting language code not found in supportedLngs: \".concat(c));\n        }\n      };\n\n      if (typeof code === 'string' && code.indexOf('-') > -1) {\n        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));\n        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));\n        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));\n      } else if (typeof code === 'string') {\n        addCode(this.formatLanguageCode(code));\n      }\n\n      fallbackCodes.forEach(function (fc) {\n        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));\n      });\n      return codes;\n    }\n  }]);\n\n  return LanguageUtil;\n}();\n\nvar sets = [{\n  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],\n  nr: [1, 2],\n  fc: 1\n}, {\n  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],\n  nr: [1, 2],\n  fc: 2\n}, {\n  lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],\n  nr: [1],\n  fc: 3\n}, {\n  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],\n  nr: [1, 2, 5],\n  fc: 4\n}, {\n  lngs: ['ar'],\n  nr: [0, 1, 2, 3, 11, 100],\n  fc: 5\n}, {\n  lngs: ['cs', 'sk'],\n  nr: [1, 2, 5],\n  fc: 6\n}, {\n  lngs: ['csb', 'pl'],\n  nr: [1, 2, 5],\n  fc: 7\n}, {\n  lngs: ['cy'],\n  nr: [1, 2, 3, 8],\n  fc: 8\n}, {\n  lngs: ['fr'],\n  nr: [1, 2],\n  fc: 9\n}, {\n  lngs: ['ga'],\n  nr: [1, 2, 3, 7, 11],\n  fc: 10\n}, {\n  lngs: ['gd'],\n  nr: [1, 2, 3, 20],\n  fc: 11\n}, {\n  lngs: ['is'],\n  nr: [1, 2],\n  fc: 12\n}, {\n  lngs: ['jv'],\n  nr: [0, 1],\n  fc: 13\n}, {\n  lngs: ['kw'],\n  nr: [1, 2, 3, 4],\n  fc: 14\n}, {\n  lngs: ['lt'],\n  nr: [1, 2, 10],\n  fc: 15\n}, {\n  lngs: ['lv'],\n  nr: [1, 2, 0],\n  fc: 16\n}, {\n  lngs: ['mk'],\n  nr: [1, 2],\n  fc: 17\n}, {\n  lngs: ['mnk'],\n  nr: [0, 1, 2],\n  fc: 18\n}, {\n  lngs: ['mt'],\n  nr: [1, 2, 11, 20],\n  fc: 19\n}, {\n  lngs: ['or'],\n  nr: [2, 1],\n  fc: 2\n}, {\n  lngs: ['ro'],\n  nr: [1, 2, 20],\n  fc: 20\n}, {\n  lngs: ['sl'],\n  nr: [5, 1, 2, 3],\n  fc: 21\n}, {\n  lngs: ['he', 'iw'],\n  nr: [1, 2, 20, 21],\n  fc: 22\n}];\nvar _rulesPluralsTypes = {\n  1: function _(n) {\n    return Number(n > 1);\n  },\n  2: function _(n) {\n    return Number(n != 1);\n  },\n  3: function _(n) {\n    return 0;\n  },\n  4: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  5: function _(n) {\n    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n  },\n  6: function _(n) {\n    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n  },\n  7: function _(n) {\n    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  8: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n  },\n  9: function _(n) {\n    return Number(n >= 2);\n  },\n  10: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n  },\n  11: function _(n) {\n    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n  },\n  12: function _(n) {\n    return Number(n % 10 != 1 || n % 100 == 11);\n  },\n  13: function _(n) {\n    return Number(n !== 0);\n  },\n  14: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n  },\n  15: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  16: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n  },\n  17: function _(n) {\n    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n  },\n  18: function _(n) {\n    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n  },\n  19: function _(n) {\n    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n  },\n  20: function _(n) {\n    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n  },\n  21: function _(n) {\n    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n  },\n  22: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n  }\n};\nvar deprecatedJsonVersions = ['v1', 'v2', 'v3'];\nvar suffixesOrder = {\n  zero: 0,\n  one: 1,\n  two: 2,\n  few: 3,\n  many: 4,\n  other: 5\n};\n\nfunction createRules() {\n  var rules = {};\n  sets.forEach(function (set) {\n    set.lngs.forEach(function (l) {\n      rules[l] = {\n        numbers: set.nr,\n        plurals: _rulesPluralsTypes[set.fc]\n      };\n    });\n  });\n  return rules;\n}\n\nvar PluralResolver = function () {\n  function PluralResolver(languageUtils) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck__default['default'](this, PluralResolver);\n\n    this.languageUtils = languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('pluralResolver');\n\n    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {\n      this.options.compatibilityJSON = 'v3';\n      this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');\n    }\n\n    this.rules = createRules();\n  }\n\n  _createClass__default['default'](PluralResolver, [{\n    key: \"addRule\",\n    value: function addRule(lng, obj) {\n      this.rules[lng] = obj;\n    }\n  }, {\n    key: \"getRule\",\n    value: function getRule(code) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.shouldUseIntlApi()) {\n        try {\n          return new Intl.PluralRules(code, {\n            type: options.ordinal ? 'ordinal' : 'cardinal'\n          });\n        } catch (_unused) {\n          return;\n        }\n      }\n\n      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n  }, {\n    key: \"needsPlural\",\n    value: function needsPlural(code) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rule = this.getRule(code, options);\n\n      if (this.shouldUseIntlApi()) {\n        return rule && rule.resolvedOptions().pluralCategories.length > 1;\n      }\n\n      return rule && rule.numbers.length > 1;\n    }\n  }, {\n    key: \"getPluralFormsOfKey\",\n    value: function getPluralFormsOfKey(code, key) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.getSuffixes(code, options).map(function (suffix) {\n        return \"\".concat(key).concat(suffix);\n      });\n    }\n  }, {\n    key: \"getSuffixes\",\n    value: function getSuffixes(code) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rule = this.getRule(code, options);\n\n      if (!rule) {\n        return [];\n      }\n\n      if (this.shouldUseIntlApi()) {\n        return rule.resolvedOptions().pluralCategories.sort(function (pluralCategory1, pluralCategory2) {\n          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];\n        }).map(function (pluralCategory) {\n          return \"\".concat(_this.options.prepend).concat(pluralCategory);\n        });\n      }\n\n      return rule.numbers.map(function (number) {\n        return _this.getSuffix(code, number, options);\n      });\n    }\n  }, {\n    key: \"getSuffix\",\n    value: function getSuffix(code, count) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var rule = this.getRule(code, options);\n\n      if (rule) {\n        if (this.shouldUseIntlApi()) {\n          return \"\".concat(this.options.prepend).concat(rule.select(count));\n        }\n\n        return this.getSuffixRetroCompatible(rule, count);\n      }\n\n      this.logger.warn(\"no plural rule found for: \".concat(code));\n      return '';\n    }\n  }, {\n    key: \"getSuffixRetroCompatible\",\n    value: function getSuffixRetroCompatible(rule, count) {\n      var _this2 = this;\n\n      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n      var suffix = rule.numbers[idx];\n\n      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n        if (suffix === 2) {\n          suffix = 'plural';\n        } else if (suffix === 1) {\n          suffix = '';\n        }\n      }\n\n      var returnSuffix = function returnSuffix() {\n        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();\n      };\n\n      if (this.options.compatibilityJSON === 'v1') {\n        if (suffix === 1) return '';\n        if (typeof suffix === 'number') return \"_plural_\".concat(suffix.toString());\n        return returnSuffix();\n      } else if (this.options.compatibilityJSON === 'v2') {\n        return returnSuffix();\n      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n        return returnSuffix();\n      }\n\n      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n    }\n  }, {\n    key: \"shouldUseIntlApi\",\n    value: function shouldUseIntlApi() {\n      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);\n    }\n  }]);\n\n  return PluralResolver;\n}();\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Interpolator = function () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck__default['default'](this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n    this.options = options;\n\n    this.format = options.interpolation && options.interpolation.format || function (value) {\n      return value;\n    };\n\n    this.init(options);\n  }\n\n  _createClass__default['default'](Interpolator, [{\n    key: \"init\",\n    value: function init() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (!options.interpolation) options.interpolation = {\n        escapeValue: true\n      };\n      var iOpts = options.interpolation;\n      this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;\n      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');\n      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');\n      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';\n      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n      this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n      this.resetRegExp();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.options) this.init(this.options);\n    }\n  }, {\n    key: \"resetRegExp\",\n    value: function resetRegExp() {\n      var regexpStr = \"\".concat(this.prefix, \"(.+?)\").concat(this.suffix);\n      this.regexp = new RegExp(regexpStr, 'g');\n      var regexpUnescapeStr = \"\".concat(this.prefix).concat(this.unescapePrefix, \"(.+?)\").concat(this.unescapeSuffix).concat(this.suffix);\n      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n      var nestingRegexpStr = \"\".concat(this.nestingPrefix, \"(.+?)\").concat(this.nestingSuffix);\n      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(str, data, lng, options) {\n      var _this = this;\n\n      var match;\n      var value;\n      var replaces;\n      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n\n      function regexSafe(val) {\n        return val.replace(/\\$/g, '$$$$');\n      }\n\n      var handleFormat = function handleFormat(key) {\n        if (key.indexOf(_this.formatSeparator) < 0) {\n          var path = getPathWithDefaults(data, defaultData, key);\n          return _this.alwaysFormat ? _this.format(path, undefined, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {\n            interpolationkey: key\n          })) : path;\n        }\n\n        var p = key.split(_this.formatSeparator);\n        var k = p.shift().trim();\n        var f = p.join(_this.formatSeparator).trim();\n        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {\n          interpolationkey: k\n        }));\n      };\n\n      this.resetRegExp();\n      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n      var todos = [{\n        regex: this.regexpUnescape,\n        safeValue: function safeValue(val) {\n          return regexSafe(val);\n        }\n      }, {\n        regex: this.regexp,\n        safeValue: function safeValue(val) {\n          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);\n        }\n      }];\n      todos.forEach(function (todo) {\n        replaces = 0;\n\n        while (match = todo.regex.exec(str)) {\n          var matchedVar = match[1].trim();\n          value = handleFormat(matchedVar);\n\n          if (value === undefined) {\n            if (typeof missingInterpolationHandler === 'function') {\n              var temp = missingInterpolationHandler(str, match, options);\n              value = typeof temp === 'string' ? temp : '';\n            } else if (options && options.hasOwnProperty(matchedVar)) {\n              value = '';\n            } else if (skipOnVariables) {\n              value = match[0];\n              continue;\n            } else {\n              _this.logger.warn(\"missed to pass in variable \".concat(matchedVar, \" for interpolating \").concat(str));\n\n              value = '';\n            }\n          } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {\n            value = makeString(value);\n          }\n\n          var safeValue = todo.safeValue(value);\n          str = str.replace(match[0], safeValue);\n\n          if (skipOnVariables) {\n            todo.regex.lastIndex += value.length;\n            todo.regex.lastIndex -= match[0].length;\n          } else {\n            todo.regex.lastIndex = 0;\n          }\n\n          replaces++;\n\n          if (replaces >= _this.maxReplaces) {\n            break;\n          }\n        }\n      });\n      return str;\n    }\n  }, {\n    key: \"nest\",\n    value: function nest(str, fc) {\n      var _this2 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var match;\n      var value;\n\n      var clonedOptions = _objectSpread$3({}, options);\n\n      clonedOptions.applyPostProcessor = false;\n      delete clonedOptions.defaultValue;\n\n      function handleHasOptions(key, inheritedOptions) {\n        var sep = this.nestingOptionsSeparator;\n        if (key.indexOf(sep) < 0) return key;\n        var c = key.split(new RegExp(\"\".concat(sep, \"[ ]*{\")));\n        var optionsString = \"{\".concat(c[1]);\n        key = c[0];\n        optionsString = this.interpolate(optionsString, clonedOptions);\n        optionsString = optionsString.replace(/'/g, '\"');\n\n        try {\n          clonedOptions = JSON.parse(optionsString);\n          if (inheritedOptions) clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);\n        } catch (e) {\n          this.logger.warn(\"failed parsing options string in nesting for key \".concat(key), e);\n          return \"\".concat(key).concat(sep).concat(optionsString);\n        }\n\n        delete clonedOptions.defaultValue;\n        return key;\n      }\n\n      while (match = this.nestingRegexp.exec(str)) {\n        var formatters = [];\n        var doReduce = false;\n\n        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n          var r = match[1].split(this.formatSeparator).map(function (elem) {\n            return elem.trim();\n          });\n          match[1] = r.shift();\n          formatters = r;\n          doReduce = true;\n        }\n\n        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n        if (value && match[0] === str && typeof value !== 'string') return value;\n        if (typeof value !== 'string') value = makeString(value);\n\n        if (!value) {\n          this.logger.warn(\"missed to resolve \".concat(match[1], \" for nesting \").concat(str));\n          value = '';\n        }\n\n        if (doReduce) {\n          value = formatters.reduce(function (v, f) {\n            return _this2.format(v, f, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {\n              interpolationkey: match[1].trim()\n            }));\n          }, value.trim());\n        }\n\n        str = str.replace(match[0], value);\n        this.regexp.lastIndex = 0;\n      }\n\n      return str;\n    }\n  }]);\n\n  return Interpolator;\n}();\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction parseFormatStr(formatStr) {\n  var formatName = formatStr.toLowerCase().trim();\n  var formatOptions = {};\n\n  if (formatStr.indexOf('(') > -1) {\n    var p = formatStr.split('(');\n    formatName = p[0].toLowerCase().trim();\n    var optStr = p[1].substring(0, p[1].length - 1);\n\n    if (formatName === 'currency' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.range) formatOptions.range = optStr.trim();\n    } else {\n      var opts = optStr.split(';');\n      opts.forEach(function (opt) {\n        if (!opt) return;\n\n        var _opt$split = opt.split(':'),\n            _opt$split2 = _toArray__default['default'](_opt$split),\n            key = _opt$split2[0],\n            rest = _opt$split2.slice(1);\n\n        var val = rest.join(':').trim().replace(/^'+|'+$/g, '');\n        if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;\n        if (val === 'false') formatOptions[key.trim()] = false;\n        if (val === 'true') formatOptions[key.trim()] = true;\n        if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);\n      });\n    }\n  }\n\n  return {\n    formatName: formatName,\n    formatOptions: formatOptions\n  };\n}\n\nvar Formatter = function () {\n  function Formatter() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck__default['default'](this, Formatter);\n\n    this.logger = baseLogger.create('formatter');\n    this.options = options;\n    this.formats = {\n      number: function number(val, lng, options) {\n        return new Intl.NumberFormat(lng, options).format(val);\n      },\n      currency: function currency(val, lng, options) {\n        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options), {}, {\n          style: 'currency'\n        })).format(val);\n      },\n      datetime: function datetime(val, lng, options) {\n        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options)).format(val);\n      },\n      relativetime: function relativetime(val, lng, options) {\n        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options)).format(val, options.range || 'day');\n      },\n      list: function list(val, lng, options) {\n        return new Intl.ListFormat(lng, _objectSpread$4({}, options)).format(val);\n      }\n    };\n    this.init(options);\n  }\n\n  _createClass__default['default'](Formatter, [{\n    key: \"init\",\n    value: function init(services) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        interpolation: {}\n      };\n      var iOpts = options.interpolation;\n      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n    }\n  }, {\n    key: \"add\",\n    value: function add(name, fc) {\n      this.formats[name.toLowerCase().trim()] = fc;\n    }\n  }, {\n    key: \"format\",\n    value: function format(value, _format, lng, options) {\n      var _this = this;\n\n      var formats = _format.split(this.formatSeparator);\n\n      var result = formats.reduce(function (mem, f) {\n        var _parseFormatStr = parseFormatStr(f),\n            formatName = _parseFormatStr.formatName,\n            formatOptions = _parseFormatStr.formatOptions;\n\n        if (_this.formats[formatName]) {\n          var formatted = mem;\n\n          try {\n            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n            var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n            formatted = _this.formats[formatName](mem, l, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));\n          } catch (error) {\n            _this.logger.warn(error);\n          }\n\n          return formatted;\n        } else {\n          _this.logger.warn(\"there was no format function for \".concat(formatName));\n        }\n\n        return mem;\n      }, value);\n      return result;\n    }\n  }]);\n\n  return Formatter;\n}();\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }\n\nfunction _isNativeReflectConstruct$2() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction removePending(q, name) {\n  if (q.pending[name] !== undefined) {\n    delete q.pending[name];\n    q.pendingCount--;\n  }\n}\n\nvar Connector = function (_EventEmitter) {\n  _inherits__default['default'](Connector, _EventEmitter);\n\n  var _super = _createSuper$2(Connector);\n\n  function Connector(backend, store, services) {\n    var _this;\n\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck__default['default'](this, Connector);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized__default['default'](_this));\n    }\n\n    _this.backend = backend;\n    _this.store = store;\n    _this.services = services;\n    _this.languageUtils = services.languageUtils;\n    _this.options = options;\n    _this.logger = baseLogger.create('backendConnector');\n    _this.waitingReads = [];\n    _this.maxParallelReads = options.maxParallelReads || 10;\n    _this.readingCalls = 0;\n    _this.state = {};\n    _this.queue = [];\n\n    if (_this.backend && _this.backend.init) {\n      _this.backend.init(services, options.backend, options);\n    }\n\n    return _this;\n  }\n\n  _createClass__default['default'](Connector, [{\n    key: \"queueLoad\",\n    value: function queueLoad(languages, namespaces, options, callback) {\n      var _this2 = this;\n\n      var toLoad = {};\n      var pending = {};\n      var toLoadLanguages = {};\n      var toLoadNamespaces = {};\n      languages.forEach(function (lng) {\n        var hasAllNamespaces = true;\n        namespaces.forEach(function (ns) {\n          var name = \"\".concat(lng, \"|\").concat(ns);\n\n          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {\n            _this2.state[name] = 2;\n          } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {\n            if (pending[name] === undefined) pending[name] = true;\n          } else {\n            _this2.state[name] = 1;\n            hasAllNamespaces = false;\n            if (pending[name] === undefined) pending[name] = true;\n            if (toLoad[name] === undefined) toLoad[name] = true;\n            if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n          }\n        });\n        if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n      });\n\n      if (Object.keys(toLoad).length || Object.keys(pending).length) {\n        this.queue.push({\n          pending: pending,\n          pendingCount: Object.keys(pending).length,\n          loaded: {},\n          errors: [],\n          callback: callback\n        });\n      }\n\n      return {\n        toLoad: Object.keys(toLoad),\n        pending: Object.keys(pending),\n        toLoadLanguages: Object.keys(toLoadLanguages),\n        toLoadNamespaces: Object.keys(toLoadNamespaces)\n      };\n    }\n  }, {\n    key: \"loaded\",\n    value: function loaded(name, err, data) {\n      var s = name.split('|');\n      var lng = s[0];\n      var ns = s[1];\n      if (err) this.emit('failedLoading', lng, ns, err);\n\n      if (data) {\n        this.store.addResourceBundle(lng, ns, data);\n      }\n\n      this.state[name] = err ? -1 : 2;\n      var loaded = {};\n      this.queue.forEach(function (q) {\n        pushPath(q.loaded, [lng], ns);\n        removePending(q, name);\n        if (err) q.errors.push(err);\n\n        if (q.pendingCount === 0 && !q.done) {\n          Object.keys(q.loaded).forEach(function (l) {\n            if (!loaded[l]) loaded[l] = {};\n            var loadedKeys = q.loaded[l];\n\n            if (loadedKeys.length) {\n              loadedKeys.forEach(function (ns) {\n                if (loaded[l][ns] === undefined) loaded[l][ns] = true;\n              });\n            }\n          });\n          q.done = true;\n\n          if (q.errors.length) {\n            q.callback(q.errors);\n          } else {\n            q.callback();\n          }\n        }\n      });\n      this.emit('loaded', loaded);\n      this.queue = this.queue.filter(function (q) {\n        return !q.done;\n      });\n    }\n  }, {\n    key: \"read\",\n    value: function read(lng, ns, fcName) {\n      var _this3 = this;\n\n      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 350;\n      var callback = arguments.length > 5 ? arguments[5] : undefined;\n      if (!lng.length) return callback(null, {});\n\n      if (this.readingCalls >= this.maxParallelReads) {\n        this.waitingReads.push({\n          lng: lng,\n          ns: ns,\n          fcName: fcName,\n          tried: tried,\n          wait: wait,\n          callback: callback\n        });\n        return;\n      }\n\n      this.readingCalls++;\n      return this.backend[fcName](lng, ns, function (err, data) {\n        if (err && data && tried < 5) {\n          setTimeout(function () {\n            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);\n          }, wait);\n          return;\n        }\n\n        _this3.readingCalls--;\n\n        if (_this3.waitingReads.length > 0) {\n          var next = _this3.waitingReads.shift();\n\n          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n        }\n\n        callback(err, data);\n      });\n    }\n  }, {\n    key: \"prepareLoading\",\n    value: function prepareLoading(languages, namespaces) {\n      var _this4 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (!this.backend) {\n        this.logger.warn('No backend was added via i18next.use. Will not load resources.');\n        return callback && callback();\n      }\n\n      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);\n      if (typeof namespaces === 'string') namespaces = [namespaces];\n      var toLoad = this.queueLoad(languages, namespaces, options, callback);\n\n      if (!toLoad.toLoad.length) {\n        if (!toLoad.pending.length) callback();\n        return null;\n      }\n\n      toLoad.toLoad.forEach(function (name) {\n        _this4.loadOne(name);\n      });\n    }\n  }, {\n    key: \"load\",\n    value: function load(languages, namespaces, callback) {\n      this.prepareLoading(languages, namespaces, {}, callback);\n    }\n  }, {\n    key: \"reload\",\n    value: function reload(languages, namespaces, callback) {\n      this.prepareLoading(languages, namespaces, {\n        reload: true\n      }, callback);\n    }\n  }, {\n    key: \"loadOne\",\n    value: function loadOne(name) {\n      var _this5 = this;\n\n      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var s = name.split('|');\n      var lng = s[0];\n      var ns = s[1];\n      this.read(lng, ns, 'read', undefined, undefined, function (err, data) {\n        if (err) _this5.logger.warn(\"\".concat(prefix, \"loading namespace \").concat(ns, \" for language \").concat(lng, \" failed\"), err);\n        if (!err && data) _this5.logger.log(\"\".concat(prefix, \"loaded namespace \").concat(ns, \" for language \").concat(lng), data);\n\n        _this5.loaded(name, err, data);\n      });\n    }\n  }, {\n    key: \"saveMissing\",\n    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n        this.logger.warn(\"did not save key \\\"\".concat(key, \"\\\" as the namespace \\\"\").concat(namespace, \"\\\" was not yet loaded\"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n        return;\n      }\n\n      if (key === undefined || key === null || key === '') return;\n\n      if (this.backend && this.backend.create) {\n        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {\n          isUpdate: isUpdate\n        }));\n      }\n\n      if (!languages || !languages[0]) return;\n      this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n  }]);\n\n  return Connector;\n}(EventEmitter);\n\nfunction get() {\n  return {\n    debug: false,\n    initImmediate: true,\n    ns: ['translation'],\n    defaultNS: ['translation'],\n    fallbackLng: ['dev'],\n    fallbackNS: false,\n    supportedLngs: false,\n    nonExplicitSupportedLngs: false,\n    load: 'all',\n    preload: false,\n    simplifyPluralSuffix: true,\n    keySeparator: '.',\n    nsSeparator: ':',\n    pluralSeparator: '_',\n    contextSeparator: '_',\n    partialBundledLanguages: false,\n    saveMissing: false,\n    updateMissing: false,\n    saveMissingTo: 'fallback',\n    saveMissingPlurals: true,\n    missingKeyHandler: false,\n    missingInterpolationHandler: false,\n    postProcess: false,\n    postProcessPassResolved: false,\n    returnNull: true,\n    returnEmptyString: true,\n    returnObjects: false,\n    joinArrays: false,\n    returnedObjectHandler: false,\n    parseMissingKeyHandler: false,\n    appendNamespaceToMissingKey: false,\n    appendNamespaceToCIMode: false,\n    overloadTranslationOptionHandler: function handle(args) {\n      var ret = {};\n      if (_typeof__default['default'](args[1]) === 'object') ret = args[1];\n      if (typeof args[1] === 'string') ret.defaultValue = args[1];\n      if (typeof args[2] === 'string') ret.tDescription = args[2];\n\n      if (_typeof__default['default'](args[2]) === 'object' || _typeof__default['default'](args[3]) === 'object') {\n        var options = args[3] || args[2];\n        Object.keys(options).forEach(function (key) {\n          ret[key] = options[key];\n        });\n      }\n\n      return ret;\n    },\n    interpolation: {\n      escapeValue: true,\n      format: function format(value, _format, lng, options) {\n        return value;\n      },\n      prefix: '{{',\n      suffix: '}}',\n      formatSeparator: ',',\n      unescapePrefix: '-',\n      nestingPrefix: '$t(',\n      nestingSuffix: ')',\n      nestingOptionsSeparator: ',',\n      maxReplaces: 1000,\n      skipOnVariables: true\n    }\n  };\n}\nfunction transformOptions(options) {\n  if (typeof options.ns === 'string') options.ns = [options.ns];\n  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];\n  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];\n\n  if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {\n    options.supportedLngs = options.supportedLngs.concat(['cimode']);\n  }\n\n  return options;\n}\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }\n\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction noop() {}\n\nfunction bindMemberFunctions(inst) {\n  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n  mems.forEach(function (mem) {\n    if (typeof inst[mem] === 'function') {\n      inst[mem] = inst[mem].bind(inst);\n    }\n  });\n}\n\nvar I18n = function (_EventEmitter) {\n  _inherits__default['default'](I18n, _EventEmitter);\n\n  var _super = _createSuper$3(I18n);\n\n  function I18n() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck__default['default'](this, I18n);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized__default['default'](_this));\n    }\n\n    _this.options = transformOptions(options);\n    _this.services = {};\n    _this.logger = baseLogger;\n    _this.modules = {\n      external: []\n    };\n    bindMemberFunctions(_assertThisInitialized__default['default'](_this));\n\n    if (callback && !_this.isInitialized && !options.isClone) {\n      if (!_this.options.initImmediate) {\n        _this.init(options, callback);\n\n        return _possibleConstructorReturn__default['default'](_this, _assertThisInitialized__default['default'](_this));\n      }\n\n      setTimeout(function () {\n        _this.init(options, callback);\n      }, 0);\n    }\n\n    return _this;\n  }\n\n  _createClass__default['default'](I18n, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (!options.defaultNS && options.ns) {\n        if (typeof options.ns === 'string') {\n          options.defaultNS = options.ns;\n        } else if (options.ns.indexOf('translation') < 0) {\n          options.defaultNS = options.ns[0];\n        }\n      }\n\n      var defOpts = get();\n      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));\n\n      if (this.options.compatibilityAPI !== 'v1') {\n        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);\n      }\n\n      if (options.keySeparator !== undefined) {\n        this.options.userDefinedKeySeparator = options.keySeparator;\n      }\n\n      if (options.nsSeparator !== undefined) {\n        this.options.userDefinedNsSeparator = options.nsSeparator;\n      }\n\n      function createClassOnDemand(ClassOrObject) {\n        if (!ClassOrObject) return null;\n        if (typeof ClassOrObject === 'function') return new ClassOrObject();\n        return ClassOrObject;\n      }\n\n      if (!this.options.isClone) {\n        if (this.modules.logger) {\n          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n        } else {\n          baseLogger.init(null, this.options);\n        }\n\n        var formatter;\n\n        if (this.modules.formatter) {\n          formatter = this.modules.formatter;\n        } else if (typeof Intl !== 'undefined') {\n          formatter = Formatter;\n        }\n\n        var lu = new LanguageUtil(this.options);\n        this.store = new ResourceStore(this.options.resources, this.options);\n        var s = this.services;\n        s.logger = baseLogger;\n        s.resourceStore = this.store;\n        s.languageUtils = lu;\n        s.pluralResolver = new PluralResolver(lu, {\n          prepend: this.options.pluralSeparator,\n          compatibilityJSON: this.options.compatibilityJSON,\n          simplifyPluralSuffix: this.options.simplifyPluralSuffix\n        });\n\n        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n          s.formatter = createClassOnDemand(formatter);\n          s.formatter.init(s, this.options);\n          this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n        }\n\n        s.interpolator = new Interpolator(this.options);\n        s.utils = {\n          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n        };\n        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n        s.backendConnector.on('*', function (event) {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n\n        if (this.modules.languageDetector) {\n          s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n          s.languageDetector.init(s, this.options.detection, this.options);\n        }\n\n        if (this.modules.i18nFormat) {\n          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n          if (s.i18nFormat.init) s.i18nFormat.init(this);\n        }\n\n        this.translator = new Translator(this.services, this.options);\n        this.translator.on('*', function (event) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n        this.modules.external.forEach(function (m) {\n          if (m.init) m.init(_this2);\n        });\n      }\n\n      this.format = this.options.interpolation.format;\n      if (!callback) callback = noop;\n\n      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n        if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];\n      }\n\n      if (!this.services.languageDetector && !this.options.lng) {\n        this.logger.warn('init: no languageDetector is used and no lng is defined');\n      }\n\n      var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];\n      storeApi.forEach(function (fcName) {\n        _this2[fcName] = function () {\n          var _this2$store;\n\n          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);\n        };\n      });\n      var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];\n      storeApiChained.forEach(function (fcName) {\n        _this2[fcName] = function () {\n          var _this2$store2;\n\n          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);\n\n          return _this2;\n        };\n      });\n      var deferred = defer();\n\n      var load = function load() {\n        var finish = function finish(err, t) {\n          if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');\n          _this2.isInitialized = true;\n          if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);\n\n          _this2.emit('initialized', _this2.options);\n\n          deferred.resolve(t);\n          callback(err, t);\n        };\n\n        if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));\n\n        _this2.changeLanguage(_this2.options.lng, finish);\n      };\n\n      if (this.options.resources || !this.options.initImmediate) {\n        load();\n      } else {\n        setTimeout(load, 0);\n      }\n\n      return deferred;\n    }\n  }, {\n    key: \"loadResources\",\n    value: function loadResources(language) {\n      var _this3 = this;\n\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n      var usedCallback = callback;\n      var usedLng = typeof language === 'string' ? language : this.language;\n      if (typeof language === 'function') usedCallback = language;\n\n      if (!this.options.resources || this.options.partialBundledLanguages) {\n        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();\n        var toLoad = [];\n\n        var append = function append(lng) {\n          if (!lng) return;\n\n          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);\n\n          lngs.forEach(function (l) {\n            if (toLoad.indexOf(l) < 0) toLoad.push(l);\n          });\n        };\n\n        if (!usedLng) {\n          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n          fallbacks.forEach(function (l) {\n            return append(l);\n          });\n        } else {\n          append(usedLng);\n        }\n\n        if (this.options.preload) {\n          this.options.preload.forEach(function (l) {\n            return append(l);\n          });\n        }\n\n        this.services.backendConnector.load(toLoad, this.options.ns, function (e) {\n          if (!e && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);\n          usedCallback(e);\n        });\n      } else {\n        usedCallback(null);\n      }\n    }\n  }, {\n    key: \"reloadResources\",\n    value: function reloadResources(lngs, ns, callback) {\n      var deferred = defer();\n      if (!lngs) lngs = this.languages;\n      if (!ns) ns = this.options.ns;\n      if (!callback) callback = noop;\n      this.services.backendConnector.reload(lngs, ns, function (err) {\n        deferred.resolve();\n        callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"use\",\n    value: function use(module) {\n      if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n      if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n\n      if (module.type === 'backend') {\n        this.modules.backend = module;\n      }\n\n      if (module.type === 'logger' || module.log && module.warn && module.error) {\n        this.modules.logger = module;\n      }\n\n      if (module.type === 'languageDetector') {\n        this.modules.languageDetector = module;\n      }\n\n      if (module.type === 'i18nFormat') {\n        this.modules.i18nFormat = module;\n      }\n\n      if (module.type === 'postProcessor') {\n        postProcessor.addPostProcessor(module);\n      }\n\n      if (module.type === 'formatter') {\n        this.modules.formatter = module;\n      }\n\n      if (module.type === '3rdParty') {\n        this.modules.external.push(module);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setResolvedLanguage\",\n    value: function setResolvedLanguage(l) {\n      if (!l || !this.languages) return;\n      if (['cimode', 'dev'].indexOf(l) > -1) return;\n\n      for (var li = 0; li < this.languages.length; li++) {\n        var lngInLngs = this.languages[li];\n        if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;\n\n        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n          this.resolvedLanguage = lngInLngs;\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"changeLanguage\",\n    value: function changeLanguage(lng, callback) {\n      var _this4 = this;\n\n      this.isLanguageChangingTo = lng;\n      var deferred = defer();\n      this.emit('languageChanging', lng);\n\n      var setLngProps = function setLngProps(l) {\n        _this4.language = l;\n        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);\n        _this4.resolvedLanguage = undefined;\n\n        _this4.setResolvedLanguage(l);\n      };\n\n      var done = function done(err, l) {\n        if (l) {\n          setLngProps(l);\n\n          _this4.translator.changeLanguage(l);\n\n          _this4.isLanguageChangingTo = undefined;\n\n          _this4.emit('languageChanged', l);\n\n          _this4.logger.log('languageChanged', l);\n        } else {\n          _this4.isLanguageChangingTo = undefined;\n        }\n\n        deferred.resolve(function () {\n          return _this4.t.apply(_this4, arguments);\n        });\n        if (callback) callback(err, function () {\n          return _this4.t.apply(_this4, arguments);\n        });\n      };\n\n      var setLng = function setLng(lngs) {\n        if (!lng && !lngs && _this4.services.languageDetector) lngs = [];\n        var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);\n\n        if (l) {\n          if (!_this4.language) {\n            setLngProps(l);\n          }\n\n          if (!_this4.translator.language) _this4.translator.changeLanguage(l);\n          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);\n        }\n\n        _this4.loadResources(l, function (err) {\n          done(err, l);\n        });\n      };\n\n      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n        setLng(this.services.languageDetector.detect());\n      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n        this.services.languageDetector.detect(setLng);\n      } else {\n        setLng(lng);\n      }\n\n      return deferred;\n    }\n  }, {\n    key: \"getFixedT\",\n    value: function getFixedT(lng, ns, keyPrefix) {\n      var _this5 = this;\n\n      var fixedT = function fixedT(key, opts) {\n        var options;\n\n        if (_typeof__default['default'](opts) !== 'object') {\n          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n            rest[_key3 - 2] = arguments[_key3];\n          }\n\n          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));\n        } else {\n          options = _objectSpread$6({}, opts);\n        }\n\n        options.lng = options.lng || fixedT.lng;\n        options.lngs = options.lngs || fixedT.lngs;\n        options.ns = options.ns || fixedT.ns;\n        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n        var keySeparator = _this5.options.keySeparator || '.';\n        var resultKey = options.keyPrefix ? \"\".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;\n        return _this5.t(resultKey, options);\n      };\n\n      if (typeof lng === 'string') {\n        fixedT.lng = lng;\n      } else {\n        fixedT.lngs = lng;\n      }\n\n      fixedT.ns = ns;\n      fixedT.keyPrefix = keyPrefix;\n      return fixedT;\n    }\n  }, {\n    key: \"t\",\n    value: function t() {\n      var _this$translator;\n\n      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);\n    }\n  }, {\n    key: \"exists\",\n    value: function exists() {\n      var _this$translator2;\n\n      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);\n    }\n  }, {\n    key: \"setDefaultNamespace\",\n    value: function setDefaultNamespace(ns) {\n      this.options.defaultNS = ns;\n    }\n  }, {\n    key: \"hasLoadedNamespace\",\n    value: function hasLoadedNamespace(ns) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.isInitialized) {\n        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n        return false;\n      }\n\n      if (!this.languages || !this.languages.length) {\n        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n        return false;\n      }\n\n      var lng = this.resolvedLanguage || this.languages[0];\n      var fallbackLng = this.options ? this.options.fallbackLng : false;\n      var lastLng = this.languages[this.languages.length - 1];\n      if (lng.toLowerCase() === 'cimode') return true;\n\n      var loadNotPending = function loadNotPending(l, n) {\n        var loadState = _this6.services.backendConnector.state[\"\".concat(l, \"|\").concat(n)];\n\n        return loadState === -1 || loadState === 2;\n      };\n\n      if (options.precheck) {\n        var preResult = options.precheck(this, loadNotPending);\n        if (preResult !== undefined) return preResult;\n      }\n\n      if (this.hasResourceBundle(lng, ns)) return true;\n      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n      return false;\n    }\n  }, {\n    key: \"loadNamespaces\",\n    value: function loadNamespaces(ns, callback) {\n      var _this7 = this;\n\n      var deferred = defer();\n\n      if (!this.options.ns) {\n        callback && callback();\n        return Promise.resolve();\n      }\n\n      if (typeof ns === 'string') ns = [ns];\n      ns.forEach(function (n) {\n        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);\n      });\n      this.loadResources(function (err) {\n        deferred.resolve();\n        if (callback) callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"loadLanguages\",\n    value: function loadLanguages(lngs, callback) {\n      var deferred = defer();\n      if (typeof lngs === 'string') lngs = [lngs];\n      var preloaded = this.options.preload || [];\n      var newLngs = lngs.filter(function (lng) {\n        return preloaded.indexOf(lng) < 0;\n      });\n\n      if (!newLngs.length) {\n        if (callback) callback();\n        return Promise.resolve();\n      }\n\n      this.options.preload = preloaded.concat(newLngs);\n      this.loadResources(function (err) {\n        deferred.resolve();\n        if (callback) callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"dir\",\n    value: function dir(lng) {\n      if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n      if (!lng) return 'rtl';\n      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];\n      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';\n    }\n  }, {\n    key: \"cloneInstance\",\n    value: function cloneInstance() {\n      var _this8 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {\n        isClone: true\n      });\n\n      var clone = new I18n(mergedOptions);\n      var membersToCopy = ['store', 'services', 'language'];\n      membersToCopy.forEach(function (m) {\n        clone[m] = _this8[m];\n      });\n      clone.services = _objectSpread$6({}, this.services);\n      clone.services.utils = {\n        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n      };\n      clone.translator = new Translator(clone.services, clone.options);\n      clone.translator.on('*', function (event) {\n        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n\n        clone.emit.apply(clone, [event].concat(args));\n      });\n      clone.init(mergedOptions, callback);\n      clone.translator.options = clone.options;\n      clone.translator.backendConnector.services.utils = {\n        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n      };\n      return clone;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        options: this.options,\n        store: this.store,\n        language: this.language,\n        languages: this.languages,\n        resolvedLanguage: this.resolvedLanguage\n      };\n    }\n  }]);\n\n  return I18n;\n}(EventEmitter);\n\n_defineProperty__default['default'](I18n, \"createInstance\", function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var callback = arguments.length > 1 ? arguments[1] : undefined;\n  return new I18n(options, callback);\n});\n\nvar instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\n\nmodule.exports = instance;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/i18next/dist/cjs/i18next.js?");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://brackets-viewer/./src/style.scss?");

/***/ }),

/***/ "./node_modules/rfdc/index.js":
/*!************************************!*\
  !*** ./node_modules/rfdc/index.js ***!
  \************************************/
/***/ (function(module) {

"use strict";
eval("\nmodule.exports = rfdc\n\nfunction copyBuffer (cur) {\n  if (cur instanceof Buffer) {\n    return Buffer.from(cur)\n  }\n\n  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nfunction rfdc (opts) {\n  opts = opts || {}\n\n  if (opts.circles) return rfdcCircles(opts)\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else if (ArrayBuffer.isView(cur)) {\n        a2[k] = copyBuffer(cur)\n      } else {\n        a2[k] = fn(cur)\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n    var o2 = {}\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), clone))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), clone))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        o2[k] = clone(cur)\n      }\n    }\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n    var o2 = {}\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        o2[k] = cloneProto(cur)\n      }\n    }\n    return o2\n  }\n}\n\nfunction rfdcCircles (opts) {\n  var refs = []\n  var refsNew = []\n\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else if (ArrayBuffer.isView(cur)) {\n        a2[k] = copyBuffer(cur)\n      } else {\n        var index = refs.indexOf(cur)\n        if (index !== -1) {\n          a2[k] = refsNew[index]\n        } else {\n          a2[k] = fn(cur)\n        }\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), clone))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), clone))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = clone(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = cloneProto(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/rfdc/index.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module) {

eval("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/arrayWithHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ (function(module) {

eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/assertThisInitialized.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module) {

eval("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/getPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/inherits.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/***/ (function(module) {

eval("function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/iterableToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module) {

eval("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/nonIterableRest.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\n\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/setPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toArray.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toArray.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ \"./node_modules/@babel/runtime/helpers/iterableToArray.js\");\n\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}\n\nmodule.exports = _toArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/toArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module) {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\n\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/typeof.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _classCallCheck; }\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _createClass; }\n/* harmony export */ });\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/esm/createClass.js?");

/***/ }),

/***/ "./src/i18n/en/translation.json":
/*!**************************************!*\
  !*** ./src/i18n/en/translation.json ***!
  \**************************************/
/***/ (function(module) {

"use strict";
eval("module.exports = JSON.parse('{\"origin-hint\":{\"seed\":\"Seed {{position}}\",\"winner-bracket\":\"Loser of WB {{round}}.{{position}}\",\"winner-bracket-semi-final\":\"Loser of WB Semi {{position}}\",\"winner-bracket-final\":\"Loser of WB Final\",\"consolation-final\":\"Loser of Semi {{position}}\",\"grand-final\":\"Winner of LB Final\"},\"match-label\":{\"winner-bracket\":\"WB\",\"loser-bracket\":\"LB\",\"standard-bracket\":\"M\",\"standard-bracket-semi-final\":\"Semi {{matchNumber}}\",\"standard-bracket-final\":\"Final\",\"double-elimination\":\"{{matchPrefix}} {{roundNumber}}.{{matchNumber}}\",\"double-elimination-semi-final\":\"{{matchPrefix}} Semi {{matchNumber}}\",\"double-elimination-final\":\"{{matchPrefix}} Final\",\"consolation-final\":\"Consolation Final\",\"grand-final-single\":\"Grand Final\",\"grand-final\":\"GF Round {{roundNumber}}\"},\"match-status\":{\"locked\":\"Locked\",\"waiting\":\"Waiting\",\"ready\":\"Ready\",\"running\":\"Running\",\"completed\":\"Completed\",\"archived\":\"Archived\"},\"abbreviations\":{\"win\":\"W\",\"loss\":\"L\",\"forfeit\":\"F\",\"position\":\"P\",\"seed\":\"#\"},\"ranking\":{\"rank\":{\"text\":\"#\",\"tooltip\":\"Rank\"},\"id\":{\"text\":\"Name\",\"tooltip\":\"Name\"},\"played\":{\"text\":\"P\",\"tooltip\":\"Played\"},\"wins\":{\"text\":\"$t(abbreviations.win)\",\"tooltip\":\"Wins\"},\"draws\":{\"text\":\"D\",\"tooltip\":\"Draws\"},\"losses\":{\"text\":\"$t(abbreviations.loss)\",\"tooltip\":\"Losses\"},\"forfeits\":{\"text\":\"$t(abbreviations.forfeit)\",\"tooltip\":\"Forfeits\"},\"scoreFor\":{\"text\":\"SF\",\"tooltip\":\"Score For\"},\"scoreAgainst\":{\"text\":\"SA\",\"tooltip\":\"Score Against\"},\"scoreDifference\":{\"text\":\"+/-\",\"tooltip\":\"Score Difference\"},\"points\":{\"text\":\"Pts\",\"tooltip\":\"Points\"}},\"common\":{\"bye\":\"BYE\",\"best-of-x\":\"Bo{{x}}\",\"group-name\":\"Group {{groupNumber}}\",\"group-name-winner-bracket\":\"Winner Bracket\",\"group-name-loser-bracket\":\"Loser Bracket\",\"round-name\":\"Round 1234 {{roundNumber}}\",\"round-name-final\":\"Final Round\",\"round-name-winner-bracket\":\"WB Round {{roundNumber}}\",\"round-name-winner-bracket-final\":\"WB Final Round\",\"round-name-loser-bracket\":\"LB Round {{roundNumber}}\",\"round-name-loser-bracket-final\":\"LB Final Round\"},\"form-creator\":{\"stage-name-label\":\"Name your stage\",\"stage-name-placeholder\":\"Give a name for your stage\",\"stage-selector-label\":\"Select a stage\",\"team-label\":\"Name your teams\",\"team-placeholder\":\"Comma separated List of Team Names (must be 2^n)\",\"group-label\":\"How many groups?\",\"group-placeholder\":\"How many groups do you want?\",\"seed-order-label\":\"How would you like to order your seeds?\",\"double-elimination-seed-order-placeholder\":\"Seed order for double elimination comma separated\",\"round-robin-mode-label\":\"Which round robin mode do you like?\",\"consolation-final-label\":\"Consolation Final\",\"skip-first-round-label\":\"Skip first round\",\"grand-final-type-label\":\"Grand final type\",\"submit\":\"Create\"}}');\n\n//# sourceURL=webpack://brackets-viewer/./src/i18n/en/translation.json?");

/***/ }),

/***/ "./src/i18n/fr/translation.json":
/*!**************************************!*\
  !*** ./src/i18n/fr/translation.json ***!
  \**************************************/
/***/ (function(module) {

"use strict";
eval("module.exports = JSON.parse('{\"origin-hint\":{\"seed\":\"Seed {{position}}\",\"winner-bracket\":\"Perdant WB {{round}}.{{position}}\",\"winner-bracket-semi-final\":\"Perdant WB Semi {{position}}\",\"winner-bracket-final\":\"Perdant Finale WB\",\"consolation-final\":\"Perdant Semi {{position}}\",\"grand-final\":\"Gagnant Finale LB\"},\"match-label\":{\"winner-bracket\":\"WB\",\"loser-bracket\":\"LB\",\"standard-bracket\":\"M\",\"standard-bracket-semi-final\":\"Semi {{matchNumber}}\",\"standard-bracket-final\":\"Finale\",\"double-elimination\":\"{{matchPrefix}} {{roundNumber}}.{{matchNumber}}\",\"double-elimination-semi-final\":\"{{matchPrefix}} Semi {{matchNumber}}\",\"double-elimination-final\":\"Finale {{matchPrefix}}\",\"consolation-final\":\"Petite finale\",\"grand-final-single\":\"Grande finale\",\"grand-final\":\"GF Round {{roundNumber}}\"},\"match-status\":{\"locked\":\"Verrouill\",\"waiting\":\"En attente\",\"ready\":\"Prt\",\"running\":\"En cours\",\"completed\":\"Termin\",\"archived\":\"Archiv\"},\"abbreviations\":{\"win\":\"V\",\"loss\":\"D\",\"forfeit\":\"F\",\"position\":\"P\",\"seed\":\"#\"},\"ranking\":{\"rank\":{\"text\":\"#\",\"tooltip\":\"Rang\"},\"id\":{\"text\":\"Name\",\"tooltip\":\"Nom\"},\"played\":{\"text\":\"J\",\"tooltip\":\"Jou\"},\"wins\":{\"text\":\"$t(abbreviations.win)\",\"tooltip\":\"Victoires\"},\"draws\":{\"text\":\"N\",\"tooltip\":\"Match nul\"},\"losses\":{\"text\":\"$t(abbreviations.loss)\",\"tooltip\":\"Dfaites\"},\"forfeits\":{\"text\":\"$t(abbreviations.forfeit)\",\"tooltip\":\"Forfaits\"},\"scoreFor\":{\"text\":\"SF\",\"tooltip\":\"Score pour\"},\"scoreAgainst\":{\"text\":\"SA\",\"tooltip\":\"Score contre\"},\"scoreDifference\":{\"text\":\"+/-\",\"tooltip\":\"Diffrence de score\"},\"points\":{\"text\":\"Pts\",\"tooltip\":\"Points\"}},\"common\":{\"bye\":\"BYE\",\"best-of-x\":\"Bo{{x}}\",\"group-name\":\"Groupe {{groupNumber}}\",\"round-name\":\"Round {{roundNumber}}\",\"round-name-final\":\"Round final\",\"round-name-winner-bracket\":\"WB Round {{roundNumber}}\",\"round-name-winner-bracket-final\":\"WB Round final\",\"round-name-loser-bracket\":\"LB Round {{roundNumber}}\",\"round-name-loser-bracket-final\":\"LB Round final\"},\"form-creator\":{\"stage-name-label\":\"Name your stage\",\"stage-name-placeholder\":\"Give a name for your stage\",\"stage-selector-label\":\"Select a stage\",\"team-label\":\"Name your teams\",\"team-placeholder\":\"Comma separated List of Team Names (must be 2^n)\",\"group-label\":\"How many groups?\",\"group-placeholder\":\"How many groups do you want?\",\"seed-order-label\":\"How would you like to order your seeds?\",\"double-elimination-seed-order-placeholder\":\"Seed order for double elimination comma separated\",\"round-robin-mode-label\":\"Which round robin mode do you like?\",\"consolation-final-label\":\"Consolation Final\",\"skip-first-round-label\":\"Skip first round\",\"grand-final-type-label\":\"Grand final type\",\"submit\":\"Create\"}}');\n\n//# sourceURL=webpack://brackets-viewer/./src/i18n/fr/translation.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;